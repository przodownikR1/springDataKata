= JPA/Hibernate camp
:docInfo1
:numbered:
:icons: font
:pagenums:
:imagesdir: images
:source-highlighter: coderay

:image-link: https://pbs.twimg.com/profile_images/425289501980639233/tUWf7KiC.jpeg

ifndef::sourcedir[:sourcedir: ./src/main/java/]

#Sample demo to show how jpa work in effiecient way

== Topic

=== MappedSuperclass

Właściwości klasy oznaczonej tą adnotacją będą propagowane na klasy pochodne. W relacji bazodanowej oznacza to, że kolumny będą propagowane do tabel pośredniczących tej strategii.
Taka klasa nie będzie miała odwzorowania w bazie danych.

NOTE: Abstract class

WARNING: Klasy z adnotacją @MappedSuperclass nie mogą być używane do wyszukiwania oraz w zapytaniach JPQL.


image::inheritance_class_diagram_mappedSuperClass.svg[]

[source,java]
----

@MappedSuperclass
public static class Account {

    @Id
    private Long id;

    private String owner;

    private BigDecimal balance;

    private BigDecimal interestRate;
    
----

[source,sql]
----

CREATE TABLE DebitAccount (
    id BIGINT NOT NULL ,
    balance NUMERIC(19, 2) ,
    interestRate NUMERIC(19, 2) ,
    owner VARCHAR(255) ,
    overdraftFee NUMERIC(19, 2) ,
    PRIMARY KEY ( id )
)

CREATE TABLE CreditAccount (
    id BIGINT NOT NULL ,
    balance NUMERIC(19, 2) ,
    interestRate NUMERIC(19, 2) ,
    owner VARCHAR(255) ,
    creditLimit NUMERIC(19, 2) ,
    PRIMARY KEY ( id )
)

----



* Tabela na klasę konkretną
* Tabela na każdą hierarchię klas
* Tabela na każdą podklasę

=== Table per class hierarchy / Single-Table Strategy 

Symulacja dziedziczenia oparta jest na jednej tabeli.


[source,java]
----
@Entity
@Table(name="employee")
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name="emp_type", discriminatorType=DiscriminatorType.STRING, length=2)
@DiscriminatorValue(value="E")
public class Employee {

}
@Entity
@Table(name = "employee")
@DiscriminatorValue(value="PE")
public class PermanentEmployee extends Employee {
}

----
*@Inheritance(strategy=InheritanceType.SINGLE_TABLE)*  - This annotation is used to define the inheritance strategy.
*@DiscriminatorColumn(name="emp_type", discriminatorType=DiscriminatorType.STRING, length=2)* - This annotation is used to define the
discriminator column for the SINGLE_TABLE and JOINED mapping strategies.

*@DiscriminatorValue(value="E")* - This annotation defines the value of the discriminator column for this particular class. If the value is not provided, hibernate
uses a class name in DiscriminatorType.STRING , and the provided specific functions will be used otherwise.

 ** String, char, int, byte, short, boolean(including yes_no, true_false).

WARNING: Each subclass in a hierarchy must define a unique discriminator value, which is used to differentiate between rows belonging to separate subclass types. If this is not specified, the DTYPE column is used as a discriminator, storing the associated subclass name.

*** Discriminator formula
- The @DiscriminatorFormula defines a custom SQL clause that can be used to identify a certain subclass type. 

[source,java]
----

@Entity(name = "Account")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorFormula(
    "case when debitKey is not null " +
    "then 'Debit' " +
    "else ( " +
    "   case when creditKey is not null " +
    "   then 'Credit' " +
    "   else 'Unknown' " +
    "   end ) " +
    "end "
)
public static class Account {

    @Id
    private Long id;
    private String owner;
    private BigDecimal balance;
    private BigDecimal interestRate;
    
@Entity(name = "DebitAccount")
@DiscriminatorValue(value = "Debit")
public static class DebitAccount extends Account {

    private String debitKey;
    private BigDecimal overdraftFee;
            
}

@Entity(name = "CreditAccount")
@DiscriminatorValue(value = "Credit")
public static class CreditAccount extends Account {

    private String creditKey;
    private BigDecimal creditLimit;
 }   
 
----

[source,sql]
----


CREATE TABLE Account (
    id int8 NOT NULL ,
    balance NUMERIC(19, 2) ,
    interestRate NUMERIC(19, 2) ,
    owner VARCHAR(255) ,
    debitKey VARCHAR(255) ,
    overdraftFee NUMERIC(19, 2) ,
    creditKey VARCHAR(255) ,
    creditLimit NUMERIC(19, 2) ,
    PRIMARY KEY ( id )
)


----







Table per class hierarchy stores all the rows in a single table and the discriminator column
is used to uniquely identify the records. Sometimes, the tables become very large if the
hierarchy is deep.

Table per class hierarchy: The class hierarchy is represented in one table.
A discriminator column identifies the type and the subclass.


== Table per subclass 
 table-per-subclass strategy, hibernate creates separate tables for each class
 
 Table per subclass: The superclass has a table, and each subclass has a table that
contains only uninherited properties; the subclass tables have a primary key that is a
foreign key of the superclass.


 
[source,java]
----
@Entity
@Table(name="employee")
@Inheritance(strategy=InheritanceType.JOINED)
public class Employee {
}
@Entity
@Table
@PrimaryKeyJoinColumn(name="emp_id")
public class ContractualEmployee extends Employee {
}
----

In this strategy, we used the @Inheritance annotation with
strategy=InheritanceType.JOINED in the Employee parent class only. For the
subclasses, we used @PrimaryKeyJoinColumn(name="emp_id") . Hibernate will create
a foreign key column in all the subtables with the value of the name attribute of the @
PrimaryKeyJoinColumn annotation.

=== @PrimaryKeyJoinColumns




== Table per concrete class

Table per concrete class with unions: The superclass can be an abstract class or even
an interface. If the superclass is concrete, an additional table is required to map the
properties of that class.


[source,java]
----
@Entity
@Table(name="employee")
@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)
public class Employee {
@Id
@GeneratedValue(strategy = GenerationType.TABLE)
@Column(name="id")
private long id;
}
@Entity
@AttributeOverrides({
@AttributeOverride(name="id", column = @Column(name="id")),
@AttributeOverride(name="name", column = @Column(name="name"))
})
public class ContractualEmployee extends Employee {
}
----
Hibernate creates a separate table for all the subclasses. We can see here that an overridden
attribute is created in each table.
The disadvantage of this strategy is that if we add, delete, or update a field in the root class, it
causes major changes in the subtable as well. This is because in this strategy, the parent class
is scattered into the other subclasses and the subclasses use the field of the parent class.


== Table per concrete class with implicit polymorphism:


Each table contains all the
properties of the concrete class and the properties that are inherited from its
superclasses. Here, all the subclasses are mapped as separate entities.


== teraz to 
Each of these different inheritance types has tradeoffs. When you create a database schema that models a class
hierarchy, you have to weigh performance and database maintainability to decide which inheritance type to use.
It is easiest to maintain your database when using the joined-table approach. If fields are added or removed from
any class in the class hierarchy, only one database table needs to be altered to reflect the changes. In addition, adding
new classes to the class hierarchy only requires that a new table be added, eliminating the performance problems of
adding database columns to large data sets. With the table-per-class approach, a change to a column in a parent class
requires that the column change be made in all child tables. The single-table approach can be messy, leading to many
columns in the table that aren’t used in every row, as well as a rapidly horizontally growing table.
Read performance will be best with the single-table approach. A select query for any class in the hierarchy will
only read from one table, with no joins necessary. The table-per-class type has great performance if you only work
with the leaf nodes in the class hierarchy. Any queries related to the parent classes will require joins on a number
of tables to get results. The joined-table approach will also require joins for any select query, so this will affect
performance. The number of joins will be related to the size of the class hierarchy—large, deep class hierarchies may
not be good candidates for the joined-table approach.
We recommend using the joined-table approach unless performance could be a problem because of the size of
the data set and the depth of the class hierarchy.

== O mnie
* programista
* blog link:http://przewidywalna-java.blogspot.com[]
* image:{image-link} [role='img-circle']