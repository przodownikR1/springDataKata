= JPA/Hibernate camp
:docInfo1
:numbered:
:icons: font
:pagenums:
:imagesdir: img
:iconsdir: ./icons
:stylesdir: ./styles
:scriptsdir: ./js

:image-link: https://pbs.twimg.com/profile_images/425289501980639233/tUWf7KiC.jpeg
ifndef::sourcedir[:sourcedir: ./src/main/java/]
ifndef::resourcedir[:resourcedir: ./src/main/resources/]
ifndef::imgsdir[:imgsdir: ./../img]
:source-highlighter: coderay


== Mapowania

=== Pola

Ten rodzaj mapowania  oparty jest na typach i nazwach pól.

=== Metody

Na poziomie właściwości klasy. Adnotację umieszcza się przy @Getter.

=== Mieszany @Access

[source,java]
----

@Entity
@Access(AccessType.FIELD)
public class Book{
@Id
@Setter
@Getter
private Long id;

private String name;

@Access(AccessType.PROPERTY)
public String getName()...
public void setName(String name)...
}
----



== **@Entity** 
- klasy,  które mają brać udział w procesie utrwalania
  
- może być abstract
- nie może być final
- nie może zawierać pola i metody final
- musi posiadać bezargumentowy konstruktor
- musi posiadać klucz główny **@Id**
- dla komunikacji (distributed/web/session/serializable) powinna implementować Serializable
- posiada wyróżnioną tożsamość


[source,java]
----
@Entity
public class Simple {
    ...
}
----


== Klucze **@Id** 

=== Prosty


=== Ustawianie wartości

==== ręczne

==== automatyczne


- każda klasa encyjna musi posiadać unikalny identyfikator.

[source,java]
----
@Id
public Long id;
----

-   **Database sequence** - wykorzystuje sekwencje
-   **Native generator** - wybiera jedną ze strategii generowania identyfikatorów : identity, sequence, hilo w zależności od możliwości bazy 
-   **Increment generator** (Identity)
-   **Hilo generator** - identyfikatory są unikalne w ramach całej bazy
-   **UUID** - generuje Stringi (unikalny w sieci adres ip + znacznik czasu). Jest to  kosztowne rozwiązanie.


==== @TableGenerator

[source,java]
----
@TableGenerator(name="Book_Gen", table="ID_GEN",pkColumnName="GEN_NAME", valueColumnName="GEN_VAL", initialValue=10000, allocationSize=100)

@Id
@GeneratedValue(generator="Book_Gen")
private Long id;
----


==== @SequenceGenerator

[source,java]
----
@SequenceGenerator(name="Book_Gen", sequenceName="Book_Seq",initialValue=10000,allocationSize=100)

@Id
@GeneratedValue(generator="Book_Gen")
private Long id;
----


=== Klucz złożony 

==== Primary key column – @Id and @IdClass

[source,java]
----
public class BookPK implements Serializable{

private String name;
private String isbn;
public int hashCode() {
return ...;
}
public boolean equals(Object obj) {
return ...;
}
}
----

[source,java]
----
@IdClass(BookPK.class)
@Entity
public class Book{
@Id
private String id;
@Id
private String isbn;
}
----



==== @Embeddable & @EmbeddedId

[source,java]
----
@Embeddable
public class BookPK implements Serializable{
}
----

[source,java]
----
@Entity
public class Book{
@EmbeddedId
private BookPk bookPk;
}
----


== **@Table**
- domyślnie nazwa tabeli jest taka sama jak nazwa klasy. Jeśli domyślne ustawienie jest nie wystarczające z różnych powodów możemy użyć @Table

[source,java]
----
@Entity
@Table( catalog = "CRM", schema = "purchasing", name = "t_simple" )
public class Simple {
    ...
}

@Entity
@Table(name = "my_emploee", uniqueConstraints = @UniqueConstraint(columnNames = { "id" , "snn"}))
class Employee{

}


---- 


== **@Column**
 - analogiczne zachowanie do adnotacji @Table

insertable and updatable = Both these attributes accept a Boolean value. This denotes whether the column takes part in
the insert and update operations or not.


[source,java]
----

    @Column(name = "retryattempt", columnDefinition = "numeric", nullable = true)
    private int retryAttempt = 0;

    @Column(name = "messageerror", columnDefinition = "nvarchar")
    private String messageError;

    @Column(name = "messagebody", length = Integer.MAX_VALUE, columnDefinition = "nvarchar")
    private String body;

    @Column(name = "detailstatus", columnDefinition = "nvarchar")
    @Enumerated(EnumType.STRING)
    private DetailStatus status;
----



== **@Transient**
- pole nie podlega procesowi utrwalania

== **@Basic**
 - określa czy pole ma być opcjonalne (przydatne podczas generowania schematu przez Hibernate).
 - określa również sposób pobierania danych, czy pole ma być wypełniane od razu przy odczycie obiektu czy dopiero przy pierwszym odwołaniu.


== @Embeddable i @Embedded**
- umożliwia osadzanie nieencyjnych obiektów Java w objektach encyjnych

== **@Enumerated**

- mapowanie enum

[source,java]
----
@Entity
public class Person {
   @Enumerated
    public Gender gender;
    public static enum Gender {
        MALE,
        FEMALE
    }
}
----

* **@AttribureConverter**

[source,java]
----
public enum Gender {

    MALE('M'),
    FEMALE('F');

    private final char code;

    private Gender( char code ) {
        this.code = code;
    }

    public static Gender fromCode( char code ) {
        if ( code == 'M' || code == 'm' ) {
            return MALE;
        }
        if ( code == 'F' || code == 'f' ) {
            return FEMALE;
        }
        throw...
    }

    public char getCode() {
        return code;
    }
}

@Entity
public class Person {
    ...

    @Basic
    @Convert( converter = GenderConverter.class )
    public Gender gender;
}

@Converter
public class GenderConverter implements AttributeConverter<Character, Gender> {

    public Character convertToDatabaseColumn( Gender value ) {
        if ( value == null ) {
            return null;
        }

        return value.getCode();
    }

    public Gender convertToEntityAttribute( Character value ) {
        if ( value == null ) {
            return null;
        }

        return Gender.fromCode( value );
    }
}
----

   

== **@Lob**

=== java.sql.Blob
  
[source,java]
----
@Entity
public class Step {
    ...
    @Lob
    @Basic
    public byte[] instructions;
    ...
}
----    

=== java.sql.Clob

[source,java]
----
@Entity
public class Product {
    ...
    @Lob
    @Basic
    public Clob description;
    ...
}
----    

    
[source,java]
----
@Entity
public class Product {
    @Basic
    @Nationalized
    public String description;
    ...
}
----    

[source,java]
----
@Entity
public class Product {
    ...

    @Lob
    @Basic
    public Clob description;
    ...
    
    @Lob
    @Basic
    public char[] description;
    
    
    @Lob
    @Basic
    public Blob instructions;
    
     @Lob
    @Basic
    public byte[] instructions;
}
----

== **Date & time**

=== DATE  

-  java.sql.Date
    
=== TIME  

-  java.sql.Time
    
=== TIMESTAMP  

- java.sql.Timestamp
   
== Mapping Java 8 Date/Time Values

[source,xml]
----
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-java8</artifactId>
    <version>${hibernate.version}</version>
</dependency>
----

=== DATE

-  java.time.LocalDate
 
[source,sql]
----
INSERT INTO DateEvent( timestamp, id ) VALUES ( '2015-12-29', 1 )
----
    
=== TIME 

-  java.time.LocalTime
-  java.time.OffsetTime
 
[source,sql]
----
INSERT INTO DateEvent( timestamp, id ) VALUES ( '16:51:58', 1 )
----
    
=== TIMESTAMP

-  java.time.Instant,
-  java.time.LocalDateTime
-  java.time.OffsetDateTime
-  java.time.ZonedDateTime

[source,sql]
----
INSERT INTO DateEvent  ( timestamp, id ) VALUES ( '2015-12-29 16:54:04.544', 1
----
    

== AttributeConverters
[source,java]
----
@Converter
public class PeriodStringConverter implements AttributeConverter<Period, String> {

    @Override
    public String convertToDatabaseColumn(Period attribute) {
        return attribute.toString();
    }

    @Override
    public Period convertToEntityAttribute(String dbData) {
        return Period.parse(dbData);
    }
}

@Entity
public class Event  {
    @Convert(converter = PeriodStringConverter.class)
    private Period span;

}
----    

== Column transformers: read and write expressions
[source,java]
----


@Entity
class CreditCard {

    @Id
    private Integer id;

    @Column(name="credit_card_num")
    @ColumnTransformer(
        read="decrypt(credit_card_num)",
        write="encrypt(?)"
    )
    private String creditCardNumber;
}
----
==  @Formula

[source,java]
----
@Formula("obj_length * obj_height * obj_width")
private long objectVolume;


@Formula("UPPER(name)")
private String capitalName;

@Formula("(SELECT c.name FROM category c WHERE c.id=category_id)")
private String categoryName;

----

== @Embedded
[source,java]
----
@Embeddable
public class Address {

    private String line1;

    private String line2;

    @Embedded
    private ZipCode zipCode;

    ...

    @Embeddable
    public static class Zip {

        private String postalCode;

        private String plus4;

        ...
    }
}
@Entity
public class Person {

    @Id
    private Integer id;

    @Embedded
    private Name name;

    ...
}
----

@Multiple embeddable types
[source,java]
----
@Entity
public class Contact {

    @Id
    private Integer id;

    @Embedded
    private Name name;

    @Embedded
    private Address homeAddress;

    @Embedded
    private Address mailingAddress;

    @Embedded
    private Address workAddress;

    ...
}
----
@AttributeOverride
[source,java]
----


@Entity
public class Contact {

    @Id
    private Integer id;

    @Embedded
    private Name name;

    @Embedded
    @AttributeOverrides(
        @AttributeOverride(
            name = "line1",
            column = @Column( name = "home_address_line1" ),
        ),
        @AttributeOverride(
            name = "line2",
            column = @Column( name = "home_address_line2" )
        ),
        @AttributeOverride(
            name = "zipCode.postalCode",
            column = @Column( name = "home_address_postal_cd" )
        ),
        @AttributeOverride(
            name = "zipCode.plus4",
            column = @Column( name = "home_address_postal_plus4" )
        )
    )
    private Address homeAddress;

    @Embedded
    @AttributeOverrides(
        @AttributeOverride(
            name = "line1",
            column = @Column( name = "mailing_address_line1" ),
        ),
        @AttributeOverride(
            name = "line2",
            column = @Column( name = "mailing_address_line2" )
        ),
        @AttributeOverride(
            name = "zipCode.postalCode",
            column = @Column( name = "mailing_address_postal_cd" )
        ),
        @AttributeOverride(
            name = "zipCode.plus4",
            column = @Column( name = "mailing_address_postal_plus4" )
        )
    )
    private Address mailingAddress;

    @Embedded
    @AttributeOverrides(
        @AttributeOverride(
            name = "line1",
            column = @Column( name = "work_address_line1" ),
        ),
        @AttributeOverride(
            name = "line2",
            column = @Column( name = "work_address_line2" )
        ),
        @AttributeOverride(
            name = "zipCode.postalCode",
            column = @Column( name = "work_address_postal_cd" )
        ),
        @AttributeOverride(
            name = "zipCode.plus4",
            column = @Column( name = "work_address_postal_plus4" )
        )
    )
    private Address workAddress;

    ...
}

----
 
 
== **@SecondaryTable** 



== @AttributeOverride

== @Version - optymistic locking
[source,java]
----
Employee employee = new Employee();
employee.setId(1);
employee.setName("przodownik");
session.saveOrUpdate(employee);
----
[source,sql]
----
Hibernate: update employee set name=?, version=? where id=? and version=?
----



== @OrderColumn
[source,java]
----
@OrderColumn(name = "index_id")
    private List<Change> changes = new ArrayList<>();
----


== @ForeignKey
[source,java]
----
@Entity
public class Phone {
 @ManyToOne
    @JoinColumn(name = "person_id",
            foreignKey = @ForeignKey(name = "PERSON_ID_FK")
    )
    }
----
[source,sql]
----

CREATE TABLE Phone (
    id BIGINT NOT NULL ,
    number VARCHAR(255) ,
    person_id BIGINT ,
    PRIMARY KEY ( id )
 )

ALTER TABLE Phone ADD CONSTRAINT PERSON_ID_FK FOREIGN KEY (person_id) REFERENCES Person
----

== Bidirectional @OneToMany


The bidirectional @OneToMany association also requires a @ManyToOne association on the child side. Although the Domain Model exposes two sides to navigate this association, behind the scenes, the relational database has only one foreign key for this relationship.

Every bidirectional association must have one owning side only (the child side), the other one being referred to as the inverse (or the mappedBy) side.





== @Type (Hibernate only) 
[source,java]
----
@org.hibernate.annotations.Type( type = "nstring" )
private String name;

@org.hibernate.annotations.Type( type = "materialized_nclob" )
private String description;
----


@UniqueConstraint(columnNames = { "id" , "empCode"}))

== Komponenty zagnieżdzone 




== @ElementCollection**  - dla typów prostych lub klas osadzonych



@ElementCollection(fetch=FetchType.LAZY)
@CollectionTable(name = "email")
@IndexColumn(name="email_index")
private List<String> emails;

@CollectionTable : This annotation indicates that the current field is of the
Collection type, and hibernate creates a separate table for it. It also creates a
reference between them. In this case, hibernate creates a table named email with
email and employee_id . The employee_id column is made by joining the persisted
class name and the primary key column of the employee class with an underscore ( _ ).
f f @ElementCollection : This annotation is used to define the relationship with the
embedded or basic type.

 
== **@OrderBy**
 - kolekcja może zostać uporządkowana według określonych kryteriów
 - w przypadku kolekcji uporządkowanej wykorzystać należy typ **List**
 
[source,java]
----

@OneToMany(mappedBy="user")
@OrderBy("lastName")
protected List<User> children;

----  

== **@JoinTable**
  -  name to  nazwa tabeli
  - joinColumns – kolumna tabeli złączenia, stanowiąca klucz dla encji
  - inverseJoinColumns – kolumna tabel złączenia, stanowiąca klucz dla encji po drugiej stronie relacji
  


== Relacje

@JoinColumn + @JoinTable

* One-To-One 1:1
[source,xml]
----
@Entity
public class Message {
@Id
Long id;

@Column
String content;
 
@OneToOne
Email email;

}
//ommit mutators and accessors 
}
----
* One-To-Many 1:N
Za pomoca kluczu obcego

Za pomoca kluczu głównego

* Many-To-One N:1
* Many-To-Many N:M


== Callbacks

=== @PrePersist
	
	Wykonanie operacji przed operacją zapisu

=== @PreRemove
	
    Wykonanie operacji przez operacją usunięcia

=== @PostPersist
	
    Wykonanie operacji po operacji zapisu

===  @PostRemove
	
    Wykonanie operacji po operacji usunięcia

=== @PreUpdate
	
    Wykonanie kodu przed operacją aktualizacji

=== @PostUpdate
	
   Wykonanie kodu po operacji aktualizacji

=== @PostLoad
	
   Wykonanie akcji po załadowaniu encji z kontekstu trwałości


== EventListener

[source,java]
----
@Entity
@EntityListeners( LastUpdateListener.class )
public static class Person {

    @Id
    private Long id;

    private String name;

    private Date dateOfBirth;

    @Transient
    private long age;

    private Date lastUpdate;

    @PostLoad
    public void calculateAge() {
        age = ChronoUnit.YEARS.between( LocalDateTime.ofInstant(
                Instant.ofEpochMilli( dateOfBirth.getTime()), ZoneOffset.UTC),
            LocalDateTime.now()
        );
    }
}

public static class LastUpdateListener {

    @PreUpdate
    @PrePersist
    public void setLastUpdate( Person p ) {
        p.setLastUpdate( new Date() );
    }
}
----


== O mnie
* programista
* blog link:http://przewidywalna-java.blogspot.com[]
* image:{image-link} [role='img-circle']
