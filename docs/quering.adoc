= JPA/Hibernate camp
:docInfo1
:numbered:
:icons: font
:pagenums:
:imagesdir: images
:source-highlighter: coderay

:image-link: https://pbs.twimg.com/profile_images/425289501980639233/tUWf7KiC.jpeg

ifndef::sourcedir[:sourcedir: ./src/main/java/]

#Sample demo to show how jpa work in effiecient way


== Topic

== Możliwe formy zapytań : 
===  zapytania HQL
-  Odpowiednik SQL, zamiast tabel i pól operuje na obiektach i jego właściwościach.
[source,java]
----

Query query = session.createQuery(sql);

----

=== Criteria API


=== native SQL


=== Hibernate Criteria

[source,java]
----
Criteria criteria = session.createCriteria(Employee.class);
criteria.add(Restrictions.eq("department.name", "account"));
List list = criteria.list();
----



== Projekcja / Projection

 - zwracanie tylko interesujących użytkownika zapytań
 - redukcja użycia pamięci 
 - zwiększona szybkość wykonania
 - zwiększona szybkość przetwarzania
 
[source,java]
----
String sql = "select b.name from Book b";

sql = "select b.id, b.name , b.isbn from Book c";

Query query = entityManager.createQuery(sql);
List<Object[]> books = query.getResultList();

----

=== Projekcja z użyciem konstruktora
 
[source,java]
----

String sql = "select pl.java.scalatech.BookDTO(b.name, b.id, b.isbn) from Book b";
Query query = entityManager.createQuery(sql);
List<BookDTO> books = query.getResultgetResultList();

---- 
 
== Restriction /  where –  zawężamy

[source,java]
----
String sql = "from Book where name="Qua vadis";
sql = "from Book where name like '%Qu'";
sql = "from Book where price > 40";

Query query = session.createQuery(sql);
List<Book> books = query.getResultList();

----


== Performing aggregate operations

== Executing a native SQL query
We can use Session.createSQLQuery(String query)

Scalar queries
[source,java]
----
SQLQuery sqlQuery = session.createSQLQuery("SELECT * FROM product");
List<Object[]> list = sqlQuery.list();
for(Object[] object : list){
System.out.println("\nId: " + object[0]);
System.out.println("Name: " + object[1]);
System.out.println("Price: " + object[2]);
System.out.println("Category id: " + object[3]);
}

SQLQuery sqlQuery = session.createSQLQuery("SELECT id, name, price,
category_id FROM product");
sqlQuery.addScalar("id", new org.hibernate.type.LongType());
sqlQuery.addScalar("name", new org.hibernate.type.StringType());
sqlQuery.addScalar("price", new org.hibernate.type.DoubleType());
sqlQuery.addScalar("category_id", new
org.hibernate.type.LongType());
sqlQuery.setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP);
List list = sqlQuery.list();



List<Object[]> persons = entityManager.createNativeQuery(
    "SELECT * FROM person" )
.getResultList();



----
Entity queries
[source,java]
----
SQLQuery sqlQuery = session.createSQLQuery("SELECT * FROM category");
/* Line 2 */ sqlQuery.addEntity(Category.class);
List<Category> list = sqlQuery.list();
for(Category category: list){
System.out.println("\nCategory id: " + category.getId());
System.out.println("Category name: " + category.getName());
}
----

=== NATIVE

[source,java]
----
List<Object[]> persons = entityManager.createNativeQuery(
    "SELECT id, name FROM person" )
.getResultList();

for(Object[] person : persons) {
    BigInteger id = (BigInteger) person[0];
    String name = (String) person[1];
}
----

=== Hibernate NATIVE

[source,java]
----


List<Object[]> persons = session.createSQLQuery(
    "SELECT * FROM person" )
.addScalar( "id", LongType.INSTANCE )
.addScalar( "name", StringType.INSTANCE )
.list();

for(Object[] person : persons) {
    Long id = (Long) person[0];
    String name = (String) person[1];
}


----

== Executing a query using HQL
[source,java]
----
Query query = session.createQuery("FROM Category");
List<Category> list = query.list();
System.out.println("Category size: " + list.size());

Query query = session.createQuery("FroM Category, Product");
List list = query.list();
System.out.println("Result size: " + list.size());

Query query = session.createQuery("SELECT id, name from Category");
List list = query.list();
System.out.println("Result size: " + list.size());

----

=== JPA native query selecting entities

[source,java]
----

List<Person> persons = entityManager.createNativeQuery(
    "SELECT * FROM person", Person.class )
.getResultList();

----

=== Hibernate native query selecting entities with the same column names and aliases

[source,java]
----
List<Object> entities = session.createSQLQuery(
    "SELECT {pr.*}, {pt.*} " +
    "FROM person pr, partner pt " +
    "WHERE pr.name = pt.name" )
.addEntity( "pr", Person.class)
.addEntity( "pt", Partner.class)
.list();
----


== Zapytania nazywane / NamedQuery

W celu wygodniejszego używania oraz większej wydajności korzysta się tzw nazwanych zapytań.

- prekompilacja
- powiązanie z encją 
- model programowy


 *@NamedQuery* : This annotation is used to define a single named query
 *@NamedQueries* : This annotation is used to define multiple queries

[source,java]
----
@NamedQuery(name="getCategoryNameByName", query="FROM Category c WHERE c.name=:name")

session.getNamedQuery("getCategoryNameByName");

@NamedQueries(
{
@NamedQuery(
name="getCategoryNameByName",
query="FROM Category c WHERE c.name=:name"
),
@NamedQuery(
name="getCategoryNameById",
query="FROM Category c WHERE c.id=:id"
),
}
)

----

IMPORTANT: Zapytania nazwane umieszcza się na klasie encyjnej

[source,java]
----

@NamedQueries({
@NamedQuery(name="Company.findAll",query="SELECT c FROM Company c"),
@NamedQuery(name="Company.findByPrimaryKey", query="SELECT c FROM Company c WHERE c.id = :id")})
Query q = entityManager.getNamedQuery("Company.findAll");

----

===  Joined-entities NamedNativeQuery

[source,java]
----


@NamedNativeQuery(
    name = "find_person_with_phones_by_name",
    query =
        "SELECT " +
        "   pr.id AS \"pr.id\", " +
        "   pr.name AS \"pr.name\", " +
        "   pr.nickName AS \"pr.nickName\", " +
        "   pr.address AS \"pr.address\", " +
        "   pr.createdOn AS \"pr.createdOn\", " +
        "   pr.version AS \"pr.version\", " +
        "   ph.id AS \"ph.id\", " +
        "   ph.person_id AS \"ph.person_id\", " +
        "   ph.number AS \"ph.number\", " +
        "   ph.type AS \"ph.type\" " +
        "FROM person pr " +
        "JOIN phone ph ON pr.id = ph.person_id " +
        "WHERE pr.name LIKE :name",
    resultSetMapping = "person_with_phones"
)
 @SqlResultSetMapping(
     name = "person_with_phones",
     entities = {
         @EntityResult(
             entityClass = Person.class,
             fields = {
                 @FieldResult( name = "id", column = "pr.id" ),
                 @FieldResult( name = "name", column = "pr.name" ),
                 @FieldResult( name = "nickName", column = "pr.nickName" ),
                 @FieldResult( name = "address", column = "pr.address" ),
                 @FieldResult( name = "createdOn", column = "pr.createdOn" ),
                 @FieldResult( name = "version", column = "pr.version" ),
             }
         ),
         @EntityResult(
             entityClass = Phone.class,
             fields = {
                 @FieldResult( name = "id", column = "ph.id" ),
                 @FieldResult( name = "person", column = "ph.person_id" ),
                 @FieldResult( name = "number", column = "ph.number" ),
                 @FieldResult( name = "type", column = "ph.type" ),
             }
         )
     }
 ),


----

=== Tuple

[source,java]
----


List<Object[]> tuples = entityManager.createNamedQuery(
    "find_person_with_phones_by_name" )
.setParameter("name", "J%")
.getResultList();

for(Object[] tuple : tuples) {
    Person person = (Person) tuple[0];
    Phone phone = (Phone) tuple[1];
}


----


== FROM

[source,java]
----

String sql = "from Book";
sql = "from Book b";
sql = "from Book as book";
sql = "pl.java.scalatech.Book";

Query query = session.createQuery(sql);
List<Book> books = query.getResultgetResultList();

----

[source,java]
----

Query query = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "where p.name like :name"
);

TypedQuery<Person> typedQuery = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "where p.name like :name", Person.class
);

----

=== Native

[source,java]
----

@NamedQueries(
    @NamedQuery(
        name = "get_person_by_name",
        query = "select p from Person p where name = :name"
    )
)

Query query = entityManager.createNamedQuery( "get_person_by_name" );

TypedQuery<Person> typedQuery = entityManager.createNamedQuery(
    "get_person_by_name", Person.class
);


----


=== Hint

[source,java]
----


Query query = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "where p.name like :name" )
// timeout - in milliseconds
.setHint( "javax.persistence.query.timeout", 2000 )
// flush only at commit time
.setFlushMode( FlushModeType.COMMIT );

----



==== javax.persistence.query.timeout

    Defines the query timeout, in milliseconds.
javax.persistence.fetchgraph

    Defines a fetchgraph EntityGraph. Attributes explicitly specified as AttributeNodes are treated as FetchType.EAGER (via join fetch or subsequent select). For details, see the EntityGraph discussions in Fetching.
==== javax.persistence.loadgraph

    Defines a loadgraph EntityGraph. Attributes explicitly specified as AttributeNodes are treated as FetchType.EAGER (via join fetch or subsequent select). Attributes that are not specified are treated as FetchType.LAZY or FetchType.EAGER depending on the attribute’s definition in metadata. For details, see the EntityGraph discussions in Fetching.
==== org.hibernate.cacheMode

    Defines the CacheMode to use. See org.hibernate.Query#setCacheMode.
==== org.hibernate.cacheable

    Defines whether the query is cacheable. true/false. See org.hibernate.Query#setCacheable.
==== org.hibernate.cacheRegion

    For queries that are cacheable, defines a specific cache region to use. See org.hibernate.Query#setCacheRegion.
==== org.hibernate.comment

    Defines the comment to apply to the generated SQL. See org.hibernate.Query#setComment.
==== org.hibernate.fetchSize

    Defines the JDBC fetch-size to use. See org.hibernate.Query#setFetchSize
==== org.hibernate.flushMode

    Defines the Hibernate-specific FlushMode to use. See org.hibernate.Query#setFlushMode. If possible, prefer using javax.persistence.Query#setFlushMode instead.
==== org.hibernate.readOnly

    Defines that entities and collections loaded by this query should be marked as read-only. See org.hibernate.Query#setReadOnly


=== Timestamp

[source,java]
----

   Query query = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "where p.createdOn > :timestamp" )
    .setParameter( "timestamp", timestamp, TemporalType.DATE );
----

=== Konkadenacja

[source,java]
---- 
String name = entityManager.createQuery(
    "select 'Customer ' || p.name " +
    "from Person p " +
    "where p.id = 1", String.class )
.getSingleResult();
----

=== Porównania

[source,java]
----


// numeric comparison
List<Call> calls = entityManager.createQuery(
    "select c " +
    "from Call c " +
    "where c.duration < 30 ", Call.class )
.getResultList();

// string comparison
List<Person> persons = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "where p.name like 'John%' ", Person.class )
.getResultList();

// datetime comparison
List<Person> persons = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "where p.createdOn > '1950-01-01' ", Person.class )
.getResultList();

// enum comparison
List<Phone> phones = entityManager.createQuery(
    "select p " +
    "from Phone p " +
    "where p.type = 'MOBILE' ", Phone.class )
.getResultList();

// boolean comparison
List<Payment> payments = entityManager.createQuery(
    "select p " +
    "from Payment p " +
    "where p.completed = true ", Payment.class )
.getResultList();

// boolean comparison
List<Payment> payments = entityManager.createQuery(
    "select p " +
    "from Payment p " +
    "where type(p) = WireTransferPayment ", Payment.class )
.getResultList();

// entity value comparison
List<Object[]> phonePayments = entityManager.createQuery(
    "select p " +
    "from Payment p, Phone ph " +
    "where p.person = ph.person ", Object[].class )
.getResultList();


----



=== Like

[source,java]
----


Query query = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "where p.name like ?1" )
.setParameter( 1, "J%" );


----

String sql = "select b.id, b.name, b.isbn from Book b";
Query query = entityManager.createQuery(sql);
List<Object[]> books = query.getResultList();

----

== Simple query using multiple root entity references

[source,java]
----

List<Object[]> persons = entityManager.createQuery(
    "select distinct pr, ph " +
    "from Person pr, Phone ph " +
    "where ph.person = pr and ph is not null", Object[].class)
.getResultList();

List<Person> persons = entityManager.createQuery(
    "select distinct pr1 " +
    "from Person pr1, Person pr2 " +
    "where pr1.id <> pr2.id " +
    "  and pr1.address = pr2.address " +
    "  and pr1.createdOn < pr2.createdOn", Person.class )
.getResultList();


----




[source,java]
----


public class CallStatistics {

    private final long count;
    private final long total;
    private final int min;
    private final int max;
    private final double abg;

    public CallStatistics(long count, long total, int min, int max, double abg) {
        this.count = count;
        this.total = total;
        this.min = min;
        this.max = max;
        this.abg = abg;
    }

    //Getters and setters omitted for brevity
}

CallStatistics callStatistics = entityManager.createQuery(
    "select new org.hibernate.userguide.hql.CallStatistics(" +
    "    count(c), " +
    "    sum(c.duration), " +
    "    min(c.duration), " +
    "    max(c.duration), " +
    "    avg(c.duration)" +
    ")  " +
    "from Call c ", CallStatistics.class )
.getSingleResult();


----

== Dynamic instantiation example - list

[source,java]
----


List<List> phoneCallDurations = entityManager.createQuery(
    "select new list(" +
    "    p.number, " +
    "    c.duration " +
    ")  " +
    "from Call c " +
    "join c.phone p ", List.class )
.getResultList();


----

==  Dynamic instantiation example - map

[source,java]
----


List<Map> phoneCallTotalDurations = entityManager.createQuery(
    "select new map(" +
    "    p.number as phoneNumber , " +
    "    sum(c.duration) as totalDuration, " +
    "    avg(c.duration) as averageDuration " +
    ")  " +
    "from Call c " +
    "join c.phone p ", Map.class )
.getResultList();


----


== Where


== Parametryzacja


== Insert

[source,java]
----

int insertedEntities = session.createQuery(
    "insert into Partner (id, name) " +
    "select p.id, p.name " +
    "from Person p ")
.executeUpdate();


----

=== Custom Insert, Update , Delete

[source,java]
----


@Entity
@Table(name = "CHAOS")
@SQLInsert( sql = "INSERT INTO CHAOS(size, name, nickname, id) VALUES(?,upper(?),?,?)")
@SQLUpdate( sql = "UPDATE CHAOS SET size = ?, name = upper(?), nickname = ? WHERE id = ?")
@SQLDelete( sql = "DELETE CHAOS WHERE id = ?")
@SQLDeleteAll( sql = "DELETE CHAOS")
@Loader(namedQuery = "chaos")
@NamedNativeQuery(name = "chaos", query="select id, size, name, lower( nickname ) as nickname from CHAOS where id= ?", resultClass = Chaos.class)
public class Chaos {
    @Id
    private Long id;
    private Long size;
    private String name;
    private String nickname;


----

=== Overriding SQL statements for collections using annotations

[source,java]
----

@OneToMany
@JoinColumn(name = "chaos_fk")
@SQLInsert( sql = "UPDATE CASIMIR_PARTICULE SET chaos_fk = ? where id = ?")
@SQLDelete( sql = "UPDATE CASIMIR_PARTICULE SET chaos_fk = null where id = ?")
private Set<CasimirParticle> particles = new HashSet<CasimirParticle>();
----

== UPDATE
[source,java]
----

int updatedEntities = entityManager.createQuery("update Person p set p.name = :newName where p.name = :oldName" )
 .setParameter( "oldName", oldName )
 .setParameter( "newName", newName )
 .executeUpdate();

----

== Delete
[source,java]
----
int deletedEntities = entityManager.createQuery("delete Person p where p.name = :name" ).setParameter( "name", name ).executeUpdate();

----

[source,java]
----
Query query=session.createQuery("delete from Employee where status=:status");
query.setString("status", "fired");
int rowsDeleted=query.executeUpdate();
----

== Between

[source,java]
----


List<Person> persons = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "join p.phones ph " +
    "where p.id = 1L and index(ph) between 0 and 3", Person.class )
.getResultList();

List<Person> persons = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "where p.createdOn between '1999-01-01' and '2001-01-02'", Person.class )
.getResultList();

List<Call> calls = entityManager.createQuery(
    "select c " +
    "from Call c " +
    "where c.duration between 5 and 20", Call.class )
.getResultList();

List<Person> persons = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "where p.name between 'H' and 'M'", Person.class )
.getResultList();


----

== IS [NOT] EMPTY

[source,java]
----
ist<Person> persons = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "where p.phones is empty", Person.class )
.getResultList();

List<Person> persons = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "where p.phones is not empty", Person.class )
.getResultList();
----

== [NOT] MEMBER [OF]

[source,java]
----
List<Person> persons = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "where 'Home address' member of p.addresses", Person.class )
.getResultList();

List<Person> persons = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "where 'Home address' not member of p.addresses", Person.class )
.getResultList();
----

== Podzapytania

[source,java]
----
SELECT b FROM Book b WHERE b.price = (SELECT MAX(emp.salary) FROM Employee emp)
----

== IN

[source,java]
----
SELECT  FROM Person p WHERE p.sex IN ('MALE', 'FEMALE')
----

== Operacje na kolekcjach

[source,java]
----
SELECT e FROM Company c  WHERE c.products IS NOT EMPTY
SELECT e FROM Company c WHERE :project MEMBER OF c.products

----

== Sortowanie

[source,java]
----
String sql = "from Book b order by b.name asc";
Query query = entityManager.createQuery(sql);
List<Book> books = query.getResultList();

----

== Agregacje

=== AVG
[source,java]
----
Object[] callStatistics = entityManager.createQuery(
    "select " +
    "    count(c), " +
    "    sum(c.duration), " +
    "    min(c.duration), " +
    "    max(c.duration), " +
    "    avg(c.duration)  " +
    "from Call c ", Object[].class )
.getSingleResult();
----

=== COUNT

[source,java]
----
Long phoneCount = entityManager.createQuery(
    "select count( distinct c.phone ) " +
    "from Call c ", Long.class )
.getSingleResult();


List<Object[]> callCount = entityManager.createQuery(
    "select p.number, count(c) " +
    "from Call c " +
    "join c.phone p " +
    "group by p.number", Object[].class )
.getResultList();

----

=== MAX
=== MIN
=== SUM

== GROUP BY

[source,java]
----



Long totalDuration = entityManager.createQuery(
    "select sum( c.duration ) " +
    "from Call c ", Long.class )
.getSingleResult();

List<Object[]> personTotalCallDurations = entityManager.createQuery(
    "select p.name, sum( c.duration ) " +
    "from Call c " +
    "join c.phone ph " +
    "join ph.person p " +
    "group by p.name", Object[].class )
.getResultList();

//It's even possible to group by entities!
List<Object[]> personTotalCallDurations = entityManager.createQuery(
    "select p, sum( c.duration ) " +
    "from Call c " +
    "join c.phone ph " +
    "join ph.person p " +
    "group by p", Object[].class )
.getResultList();


----


== HAVING

[source,java]
----

List<Object[]> personTotalCallDurations = entityManager.createQuery(
    "select p.name, sum( c.duration ) " +
    "from Call c " +
    "join c.phone ph " +
    "join ph.person p " +
    "group by p.name " +
    "having sum( c.duration ) > 1000", Object[].class )
.getResultList();
----


== Order by

[source,java]
----


List<Person> persons = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "order by p.name", Person.class )
.getResultList();

List<Object[]> personTotalCallDurations = entityManager.createQuery(
    "select p.name, sum( c.duration ) as total " +
    "from Call c " +
    "join c.phone ph " +
    "join ph.person p " +
    "group by p.name " +
    "order by total", Object[].class )
.getResultList();


----

== Stronicowanie


[source,java]
----
String sql = "from Book";
Query query = entityManager.createQuery(sql);
query.setFirstResult(10);
query.setMaxResults(25);
List<Book> books = query.getResultList();
----

== Pobieranie pojedyńczego wyniku

[source,java]
----
String sql = "from Book b where b.id=:id";
Query query = entityManager.createQuery(sql);
query.setLong("id", 1);
Book book = (Book)query.getSingleResult();
----

WARNING:  **org.hibernate.NonUniqueResultException** gdy metoda zwróci więcej niż jedne obiekt

NOTE: Zwraca pojedyńczy obiekt lub **null** jeśli takiego obiektu nie ma w bazie
 
[source,java]
----
String hql = "from Product where price > 21.0";
Query query = session.createQuery(hql);
query.setMaxResults(1);
Product product = (Product) query.uniqueResult();
----
 

== JOIN

[source,java]
----

List<Person> persons = entityManager.createQuery(
    "select distinct pr " +
    "from Person pr " +
    "join pr.phones ph " +
    "where ph.type = :phoneType", Person.class )
.setParameter( "phoneType", PhoneType.MOBILE )
.getResultList();

// same query but specifying join type as 'inner' explicitly
List<Person> persons = entityManager.createQuery(
    "select distinct pr " +
    "from Person pr " +
    "inner join pr.phones ph " +
    "where ph.type = :phoneType", Person.class )
.setParameter( "phoneType", PhoneType.MOBILE )
.getResultList();


----

== JOIN LEFT

[source,java]
----

List<Person> persons = entityManager.createQuery(
    "select distinct pr " +
    "from Person pr " +
    "left join pr.phones ph " +
    "where ph is null " +
    "   or ph.type = :phoneType", Person.class )
.setParameter( "phoneType", PhoneType.LAND_LINE )
.getResultList();

// functionally the same query but using the 'left outer' phrase
List<Person> persons = entityManager.createQuery(
    "select distinct pr " +
    "from Person pr " +
    "left outer join pr.phones ph " +
    "where ph is null " +
    "   or ph.type = :phoneType", Person.class )
.setParameter( "phoneType", PhoneType.LAND_LINE )
.getResultList();


List<Object[]> personsAndPhones = session.createQuery(
    "select pr.name, ph.number " +
    "from Person pr " +
    "left join pr.phones ph with ph.type = :phoneType " )
.setParameter( "phoneType", PhoneType.LAND_LINE )
.list();



----

== JOIN FETCH

[source,java]
----

List<Person> persons = entityManager.createQuery(
    "select distinct pr " +
    "from Person pr " +
    "left join fetch pr.phones ", Person.class )
.getResultList();
----




== JPQL standardized functions

=== CONCAT

[source,java]
----


List<String> callHistory = entityManager.createQuery(
    "select concat( p.number, ' : ' ,c.duration ) " +
    "from Call c " +
    "join c.phone p", String.class )
.getResultList();


----

=== SUBSTRING

[source,java]
----


List<String> prefixes = entityManager.createQuery(
    "select substring( p.number, 0, 2 ) " +
    "from Call c " +
    "join c.phone p", String.class )
.getResultList();


----

=== UPPER

[source,java]
----
List<String> names = entityManager.createQuery(
    "select upper( p.name ) " +
    "from Person p ", String.class )
.getResultList();
----

=== LOWER

[source,java]
----
List<String> names = entityManager.createQuery(
    "select lower( p.name ) " +
    "from Person p ", String.class )
.getResultList();
----
=== TRIM
 
[source,java]
----
List<String> names = entityManager.createQuery(
    "select trim( p.name ) " +
    "from Person p ", String.class )
.getResultList();
----
=== LENGTH
 
[source,java]
----

List<Integer> lengths = entityManager.createQuery(
    "select length( p.name ) " +
    "from Person p ", Integer.class )
.getResultList();

----


=== ABS
 
[source,java]
----

List<Integer> abs = entityManager.createQuery(
    "select abs( c.duration ) " +
    "from Call c ", Integer.class )
.getResultList();

----

=== MOD
 
[source,java]
----

List<Integer> mods = entityManager.createQuery(
    "select mod( c.duration, 10 ) " +
    "from Call c ", Integer.class )
.getResultList();

----


=== SQRT
 
[source,java]
----

List<Double> sqrts = entityManager.createQuery(
    "select sqrt( c.duration ) " +
    "from Call c ", Double.class )
.getResultList();

----


=== CURRENT_DATE
 
[source,java]
----

List<Call> calls = entityManager.createQuery(
    "select c " +
    "from Call c " +
    "where c.timestamp = current_date", Call.class )
.getResultList();



----


=== CURRENT_TIME
 
[source,java]
----

List<Call> calls = entityManager.createQuery(
    "select c " +
    "from Call c " +
    "where c.timestamp = current_time", Call.class )
.getResultList();

----

=== CURRENT_TIMESTAMP

[source,java]
----

List<Call> calls = entityManager.createQuery(
    "select c " +
    "from Call c " +
    "where c.timestamp = current_timestamp", Call.class )
.getResultList();

----

== HQL functions


=== CAST

[source,java]
----

List<String> durations = entityManager.createQuery(
    "select cast( c.duration as string ) " +
    "from Call c ", String.class )
.getResultList();

----

=== EXTRACT

[source,java]
----

List<Integer> years = entityManager.createQuery(
    "select extract( YEAR from c.timestamp ) " +
    "from Call c ", Integer.class )
.getResultList();

----
=== YEAR

[source,java]
----
List<Integer> years = entityManager.createQuery(
    "select year( c.timestamp ) " +
    "from Call c ", Integer.class )
.getResultList();

----

=== MONTH

    Abbreviated extract form for extracting the month.
=== DAY

    Abbreviated extract form for extracting the day.
=== HOUR

    Abbreviated extract form for extracting the hour.
=== MINUTE

    Abbreviated extract form for extracting the minute.
===  SECOND

    Abbreviated extract form for extracting the second.


== Entity type

[source,java]
----
List<Payment> payments = entityManager.createQuery(
    "select p " +
    "from Payment p " +
    "where type(p) = CreditCardPayment", Payment.class )
.getResultList();
List<Payment> payments = entityManager.createQuery(
    "select p " +
    "from Payment p " +
    "where type(p) = :type", Payment.class )
.setParameter( "type", WireTransferPayment.class)
.getResultList();
----

== Simple CASE expressions

[source,java]
----


List<String> nickNames = entityManager.createQuery(
    "select " +
    "    case p.nickName " +
    "    when 'NA' " +
    "    then '<no nick name>' " +
    "    else p.nickName " +
    "    end " +
    "from Person p", String.class )
.getResultList();

// same as above
List<String> nickNames = entityManager.createQuery(
    "select coalesce(p.nickName, '<no nick name>') " +
    "from Person p", String.class )
.getResultList();

----


== O mnie
* programista
* blog link:http://przewidywalna-java.blogspot.com[]
* image:{image-link} [role='img-circle']