= JPA/Hibernate camp
:docInfo1
:numbered:
:icons: font
:pagenums:
:imagesdir: images
:source-highlighter: coderay

:image-link: https://pbs.twimg.com/profile_images/425289501980639233/tUWf7KiC.jpeg

ifndef::sourcedir[:sourcedir: ./src/main/java/]

#Sample demo to show how jpa work in effiecient way

== Topic

== Lazy

Lazy loading has long been regarded as one of Hibernate’s most valuable features, especially with
respect to improving performance. By declaring a domain object’s association or property to be lazy, an
application can avoid undue overhead on the underlying database, which can often lead to faster
response times and smaller datasets—both favorable qualities.

The problem is that lazy loading is a double-edged sword. It is vital for maintaining decent loading
performance, but is also a significant risk for major performance problems. While lazy loading reduces
the amount of data (as well as the potential for table joins) loaded from the database, this laziness can be
very problematic for data that might need to be loaded from the database anyway.
This is not to imply that lazy loading is a bad feature or that it should be disabled. It is a
misunderstood problem that is very dependent on the context.
Let’s begin by looking at one of the most common and significant issues related to lazy loading that
affects persistence-based applications.

=== less lazy loading

@ManyToMany
@Fetch(FetchMode.JOIN)
public Set<ArtEntity> getArtEntities() {
return artEntities;
}

=== Batching for Performance
@ManyToMany
@BatchSize(size = 10)
public Set<ArtEntity> getArtEntities() {
return artEntities;
}

Now, even though our artEntities association is still lazy by default, Hibernate will get ahead of us
and attempt to initialize more than just a single artEntities collection at a time. It accomplishes this by
using a SQL in condition, passing in ten identifiers of a Category instance when loading from the
ArtEntity table.
In other words, batching works similarly to the default lazy configuration. First a Category is loaded,
then its artEntities association is loaded in a separate query (when the artEntities property is
accessed, of course). However, with batching enabled, Hibernate will attempt to load more than one
artEntities association, querying for the number of associations specified in the size attribute of the
@BatchSize annotation.
Keep in mind that @BatchSize doesn’t attempt to load multiple items within a collection. A
collection is normally initialized in entirety via a separate select. Rather, @BatchSize will load multiple
associations, to preclude initialization of other associations in our other Category instances (using our
example).

=== OpenInView

[source,xml]
----
<bean name="openEntityManagerInViewInterceptor" class="org.springframework.orm.jpa.support.OpenEntityManagerInViewInterceptor" />
----

[source,xml]
----
<filter>
<filter-name>OpenEntityManagerInViewFilter</filter-name>
<filter-class>org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter</filter-
class>
</filter>
<!—Map the EntityManager Filter to all requests -->
<filter-mapping>
<filter-name>OpenEntityManagerInViewFilter</filter-name>
<url-pattern>/*</url-pattern>
</filter-mapping>
----

* Analiza logów Hibernate - poprawa wolnych zapytań

* Analiza statystyk
You can use these information during development and check them against your expectations. 
By doing this regularly, you can avoid the most common issues caused by slow queries, too many queries and missing cache usage. 
And keep in mind that you are working with a small test database. 
5 or 10 additional queries during your test might be several hundreds or thousands, if you switch to the bigger production database.

* Wybór strategii pobierania danych : fetchType

  FETCH JOIN
[source,sql]
----
  SELECT DISTINCT a FROM Author a JOIN FETCH a.books b
----

@NamedEntityGraph

[source,sql]
----
@NamedEntityGraph(name = "graph.AuthorBooksReviews",  attributeNodes = @NamedAttributeNode(value = "books"))
----
 
* Ciężkie zapytania np raporty powinny być wykonywane po stronie bazy
@NamedStoredProcedureQuery

* Użyj cache 
The 1st level cache is activated by default and caches all entities that were used within the current session.   

The session independent 2nd level cache also stores entities but needs to be activated by setting the shared-cache-mode property in the persistence.xml. 
The caching of specific entities can be activated by adding the javax.persistence.
Cacheable or the org.hibernate.annotations.Cache annotation to the entity.

The query cache is the only one which does not store entities.
 It caches query results and contains only entity references and scalar values.
  You need to activate the cache by setting the hibernate.cache.use_query_cache property in the persistence.xml file and set the cacheable
   property on the Query.

* Masowe operacje UPDATE i DELETE
CriteriaUpdate and CriteriaDelete 

Updating or deleting one entity after the other feels quite natural in Java but it is also very inefficient. Hibernate creates one SQL query for each entity that was updated or deleted. The better approach would be to perform these operations in bulks by creating update or delete statements that affect multiple records at once.

[source,java]
----
CriteriaBuilder cb = this.em.getCriteriaBuilder();
  
// create update
CriteriaUpdate<Order> update = cb.createCriteriaUpdate(Order.class);

// set the root class
Root e = update.from(Order.class);

// set update and where clause
update.set("amount", newAmount);
update.where(cb.greaterThanOrEqualTo(e.get("amount"), oldAmount));

// perform update
this.em.createQuery(update).executeUpdate();
----

* Strategie pobierania (Fetching Strategies)

** Eager
   - natychmiatowe
   - czasem wygodne do użycia
   - znaczący przyrost danych pobieranych z bazy 
   
** Lazy
   - opóźniony/odroczony dostęp do danych
   - proxy
   
   
** Extra lazy
   - tylko dla kolekcji
   - nie dociąga całej kolekcji 
      

* Second level cache

* Query cache

== Performing enhancement

=== Run-time enhancement



==== enableLazyInitialization Whether enhancement for lazy attribute loading should be done.
==== enableDirtyTracking Whether enhancement for self-dirty tracking should be done.
==== enableAssociationManagement Whether enhancement for bi-directional association management should be done.


=== Gradle

[source,groovy]
----
ext {
    hibernateVersion = 'hibernate-version-you-want'
}

buildscript {
    dependencies {
        classpath "org.hibernate:hibernate-gradle-plugin:$hibernateVersion"
    }
}

hibernate {
    enhance {
        enableLazyInitialization= false
        enableDirtyTracking = false
        enableAssociationManagement = false
    }
}
}
----

=== Maven

[source,xml]
----
<build>
    <plugins>
        [...]
        <plugin>
            <groupId>org.hibernate.orm.tooling</groupId>
            <artifactId>hibernate-enhance-maven-plugin</artifactId>
            <version>$currentHibernateVersion</version>
            <executions>
                <execution>
                    <configuration>
                        <failOnError>true</failOnError>
                        <enableLazyInitialization>true</enableLazyInitialization>
                        <enableDirtyTracking>true</enableDirtyTracking>
                        <enableAssociationManagement>true</enableAssociationManagement>
                    </configuration>
                    <goals>
                        <goal>enhance</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
        [...]
    </plugins>
</build>
----


== Inne
    using too many SQL queries to fetch the required entities from the database, aka the so called n+1 query problem
    updating entities one by one instead of doing it in using a single statement
    doing data heavy processing on the Java side, rather than the database side





