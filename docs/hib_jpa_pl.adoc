= JPA/Hibernate camp
:docInfo1
:numbered:
:icons: font
:pagenums:
:imagesdir: ./img
:iconsdir: ./icons
:stylesdir: ./styles
:scriptsdir: ./js

:image-link: https://pbs.twimg.com/profile_images/425289501980639233/tUWf7KiC.jpeg
ifndef::sourcedir[:sourcedir: ./src/main/java/]
ifndef::resourcedir[:resourcedir: ./src/main/resources/]

:source-highlighter: coderay



== Topic

image::hibernate.png

**Zalety**

Standardowe podejście oparte na JDBC wymaga od programisty następujących czynności:
 
 - Opening a database connection
 - Maintaining an open connection
 - Building a query
 - Executing a query
 - Getting a response to the query
 - Mapping the query response with the custom classes
 - Closing the database connection


**Czyli ORM :**
[options=interactive]

*    redukuje znaczenie ilość kodu potrzebnego to stworzenia i wykonania zapytania 
*    redukuje koszt i czas deploymentu
*    redukcja boilerplate JDBC 
*    skupienie na problemach biznesowych 
*    mniej synchronizacji kodu z relacyjną bazą danych
*    zwiększa szybkość wytwarzania (produktywność - metaDane, query data)
*    dostarcza mechanizmy przenośności na inne bazy (nie musimy ograniczać się do danego typu bazy )  (portability)

**   **Dostępne dialekty :** 
   
***	 DB2Dialect (supports DB2)
***	 FrontBaseDialect
***	 HSQLDialect
***	 InformixDialect
***	 IngresDialect
***	 InterbaseDialect
***	 MySQLDialect
***	 Oracle8Dialect
***	 Oracle9Dialect
***	 Oracle10Dialect
***	 PointbaseDialect
***	 PostgreSQLDialect
***	 ProgressDialect
***	 SybaseDialect 
   
 
* idealnie nadaje się do protytypowania  
 
**Dodatkowo otwiera możliwości :** 

* reużywalności kodu
* zarządzania transakcjami
* wydajnego operowania na kolekcjach relacji
* wbudowany mechanizm cache'u
* wprowadza obiektowe techniki do świata relacyjnych baz danych
 
**Wady:**


* krzywa nauki 
* dodatkowy narzut na zapytania (overhead)
* w pewnych przypadkach powoduje spadek wydajności z stosunku do zwykłych zapytania JDBC
* wraz ze wzrostem złożoności modelu domenowego występują trudności z mapowaniem, wydajnością. Skutkuje to często wprowadzaniem 'haków' 
 

== Moduły
[square]
**Hibernate Core**

-  odpowiada za generowanie natywnych kwerent SQL
-  dostarcza dialekty 
-  dostarcza mechanizmy obsługi i translacji zapytań jak : HQL, Criteria Query czy QBE
-  odpowiada za buforowanie i efektywne pobieranie danych - czyli optymalizuje zapytania 
 
**Hibernate Annotation**

-  dostarcza znacziki metadanych równorzędne do konfiguracji mapować w XML

**Hibernate EntityManager**

- jest implementacją interfejsu JPA
 
**Hibernate Search**

-  dostarcza rozwiązań użycia indeksów Lucene
 
**Hibernate Validator**

-  obsługa walidacji danych
 
**Hibernate OGM**

-  rozwiazania NoSql
 
**DataSourcePool**
 
- hibernate-c3p0  Integrates the C3P0 connection pooling library into Hibernate 
- hibernate-hikaricp  Integrates the HikariCP connection pooling library into Hibernate
- hibernate-proxool   Integrates the Proxool connection pooling library into Hibernate
 
**Cache**

*hibernate-ehcache*  Integrates the Ehcache caching library into Hibernate as a second-level cache provider.
    
*hibernate-infinispan* Integrates the Infinispan caching library into Hibernate as a second-level cache provider.
 
 
 
   

* Problem on granularity

== Minimalna konfiguracja projektu :

== Hibernate
- [ ] Maven

[source, xml]
-----
   <dependencies>
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>4.3.5.Final</version>
		</dependency>
	</dependencies>
-----
 
- [ ] Gradle
 
 * Konfiguracja bazy 
- [ ] maven

[source,xml]
----

<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <version>1.4.178</version>
</dependency>

----
**Możliwe typy konfiguracji :** 
  - konfiguracja bezpośrednio w kodzie
[source,java]
----

   Configuration configuration = new Configuration().addResource("Book.hbm.xml")
.setProperty("hibernate.dialect", "org.hibernate.dialect.DerbyTenSevenDialect")
.setProperty("hibernate.connection.driver_class", "org.apache.derby.jdbc.EmbeddedDriver")
.setProperty("hibernate.connection.url", "jdbc:derby://localhost:1527/BookDB")
.setProperty("hibernate.connection.username", "book")
.setProperty("hibernate.connection.password", "book");
 
ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build();
sessionFactory = configuration.buildSessionFactory(serviceRegistry);

----
- konfiguracja xml 
- konfiguracja z użyciem plików properties
  
 
* Pojęcia
**  Encja
**  PersistenceUnit

[source,java]
----

@PersistenceUnit(unitName="pu-unit")
private EntityManagerFactory emf;

----

** PersistenceContext
  
[source,java]
----

@PersistenceContext (unitName = "pu-unit")
EntityManager entityManager;

----
  
== Nowości w JPA 2.1
Querying Stored Procedure

[source,java]
----

  @Test
    public void testCallStoreProcedure() {       
        StoredProcedureQuery query = em.createStoredProcedureQuery("my_sum");
        query.registerStoredProcedureParameter("x",Integer.class,ParameterMode.IN);
        query.registerStoredProcedureParameter("y",Integer.class,ParameterMode.IN);
        query.registerStoredProcedureParameter("sum",Integer.class,ParameterMode.OUT);
        
        query.setParameter("x", 5);
        query.setParameter("y", 4);
        query.execute();
        Integer sum = (Integer) query.getOutputParameterValue("sum");
        assertEquals(sum, new Integer(9));
    }
    
----

Attribute Converter
 
[source,java]
----

@Converter
public class PasswordConverter implements AttributeConverter<String, String> {
    @Override
    public String convertToDatabaseColumn(String arg0) {
        if(arg0!=null) {
            return Base64.getEncoder().encodeToString(arg0.getBytes());
        } else {
            return null;
        }
    }

    @Override
    public String convertToEntityAttribute(String arg0) {
        if(arg0!=null) {
            return new String(Base64.getDecoder().decode(arg0));
        } else {
            return null;
        }
    }
}

----
 
[source,java]
----

@Entity
public class Person {
    @Convert(converter=PasswordConverter.class)
    String password;
----
Constructor Result Mapping
 @ConstructorResult annotation is a handy addition to the already existing @SqlResultSetMapping and can be used to map the result of a query to a constructor call. 
[source,java]
----
@Entity
@NamedNativeQuery(name = "findWithTodoResultSetMapper", query = "SELECT id, description FROM TODO where description like ?1", resultSetMapping = "TodoResultSetMapper")
@SqlResultSetMapping(name = "TodoResultSetMapper", classes = @ConstructorResult(targetClass = org.hall.jpa.model.TodoPOJO.class, columns = {
		@ColumnResult(name = "id", type = Long.class),
		@ColumnResult(name = "description") }))
public class Todo {
	private Long id;
	private String summary;
	private String description;

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	
---- 

Programmatic Named Queries
addNamedQuery(String name, Query query) 
[source,java]
----

Query q = this.em.createQuery("SELECT a FROM Book b JOIN b.authors a WHERE b.title LIKE :title GROUP BY a");
this.em.getEntityManagerFactory().addNamedQuery("selectAuthorOfBook", q);

TypedQuery<Author> nq = this.em.createNamedQuery("selectAuthorOfBook", Author.class);
nq.setParameter("title", "%Java%");
List<Author> authors = nq.getResultList();

----

Named Entity Graph

Java 8 Date Time API
The Hibernate support for Java 8 Date Time API is provided in a separate module called hibernate-java8


* Connection pooling

Tworzenie  połączeń do bazy danych  jest kosztowne.
Hibernate dostarcza gotowe rozwiązanie do poolingu. Jednak rozwiązanie nie jest zalecane w produkcyjnym środowisku.
Zalecane w środowiskach produkcyjnych jest wykorzystanie zewnętrzych poll poprzez odwołania z JNDI lub konfigurowane zewnętrznie poprzez classpath czy odpowienie pliki properties.

Przykład zewnętrznej puli połączeń c3p0: 

[source,xml]
----
<dependencies>
   <dependency>
       <groupId>org.hibernate</groupId>
       <artifactId>hibernate-c3p0</artifactId>
       <version>[4.2.6,4.2.9)</version>
    </dependency>
  <dependency>
       <groupId>com.mchange</groupId>
       <artifactId>c3p0</artifactId>
       <version>[0.9.2.1,)</version>
  </dependency>
</dependencies>
----

Aby użyć powyższą konfigurację c3p0 wszystko co musimy zrobić to dodać wpis do konfiguracji hibernate: 
[source,xml]
----
<property name="c3p0.timeout">10</property>
----
W ten sposób Hibernate wyłączy wewnętrzną pulę połączeń i przestawi się na zewnętrzną.

* Inne rozwiązania to : 
   http://proxool.sourceforge.net/
   boneCp
   Apache poll connection
   hikarii
   Spring poll connection
   
   
== Cykl życia   
* Transient - obiekt istnie w pamięci i jest rozłączony od kontekstu Hibernate. Taki obiekt nie może być zarządzany przez Hibernate
  ** Tworzony za pomocą operatora new. Nie skojarzony z sesją.
   
   Utrwalenie:  save(), persist(), saveOrUpdate()
   save() i persist() -> Insert
   update() i merge() -> Update
   
* Persistence - obiekt istnieje w bazie danych. Obiekt jest zarządzany przez Hibernate czyli jest związany z sesją.
 
   Usunięcie : delete()
 
* Detached - obiekt ma reprezentacje w bazie danych, ale zmiana wartości obiektu nie ma wpływu na reprezentacje bazodanową i odwrotnie.

   Był trwały ale został odłączony od sesji.
   Możliwy do modyfikacji poza kontekstem.
   Przyłączenie do sesji jest możliwe
   
*  Removed - obiekty były zarządzane przez Hibernate, ale w wyniku operacji remove() zostały skasowane z bazy danych.

==Session Factory

- Służy do tworzenia obiektów Session (tworzenie, zarządzanie i pobieranie Session) 
- Jedna na kontekst (singleton pattern)
- thread-safe (immutable)
- ciężka i kosztowna do stworzenia
- konfigurowalna programowo lub poprzez konfiguracją xml


[source,java]
----
----
SessionFactory factory = configuration.buildSessionFactory(serviceRegistry);

[source,xml]
----
<hibernate-configuration>
<session-factory>
<!-- H2 Configuration -->
<property name="connection.driver_class">org.h2.Driver</property>
<property name="connection.url">jdbc:h2:file:./chapter1</property>
<property name="connection.username">sa</property>
<property name="connection.password"></property>
 
<property name="hibernate.dialect">org.hibernate.dialect.H2Dialect</property>
<property name="hibernate.show_sql">true</property>
<property name="hibernate.hbm2ddl.auto">create</property>
<mapping resource="Book.hbm.xml"/>
<mapping resource="Publisher.hbm.xml"/>
</session-factory>
</hibernate-configuration>
----
 

 
== Session 
- [ ] 'Unit of work'
- [ ]  Obsługuje transakcje
- [ ]  Lekka i szybka do stworzenia
- [ ] można ją traktować jako fizyczne buforowalne połączenie z bazą danych
- [ ]  jedno wątkowy
- [ ] krótki okres życia  
 
    
Otwieranie nowej sesji : 
[source,java]
----
Session session = sessionFactory.openSession();
----

 
== Tworzenie i zamykanie sesji

Otwieranie nowej sesji dla każdej transakcji bazowanowej jest dobrą praktyką (wielowątkowość)



SessionFactory sessionFactory =
HibernateUtil.getSessionFactory();
Session session = sessionFactory.getCurrentSession();
It may seem easy to get the current session, but the twist here is that you have to provide
more configuration to the Configuration object if you plan to reuse the Session , as
shown in the following code:
<property name="hibernate.current_session_context_class">
Thread
</property>

A Hibernate Session object represents a unit of work and is bound to the current thread. It also represents a
transaction in a database. A session begins when getCurrentSession() is first called on the current thread.
The Session object is then bound to the current thread. When the trans
[source,java]
----
Session session = factory.openSession();
try {
// Using the session to retrieve objects
}catch(Exception e)
{
e.printStackTrace();
} finally {
session.close();
}
----

== Transaction 
 - jedno wątkowy
 - określa granice jednej transakcji
 - 

== Opening a stateless session

== Tożsamość obiektu : Equals & hashcode
  - brak (Object) - (oparte na nie odłączanych encjach)
  - ID tożsamość bazodanowa
  - klucz biznesowy 
  - application managed id - (z bazy danych na aplikacje) (moment poczęcia lub urodzenia) 



== Object Equality and Identity
   
== Pobieranie encji
* load()

Na podstawie danego Id metoda load próbuje pobrać obiekt z bazy danych. Jeśli obiekt nie istnieje wyrzucany jest wyjątek org.hibernate.ObjectNotFoundException
Metoda load() zwraca też proxy, oznacza to tyle, że nie nastąpi uderzenie do bazy danych do czasu kiedy faktycznie będziemy potrzebować danego obiektu.
Proxy zwraca dummy object zamiast uderzyć do db. Jeśli obiekt jest w first-level cache zwróci obiekt.
Jeśli obiektu nie ma w first-level-cache uderzy do bazy.



[source,java]
----
public Object load(Class theClass, Serializable id) throws HibernateException
public Object load(String entityName, Serializable id) throws HibernateException
public void load(Object object, Serializable id) throws HibernateException
----

* Lock

* NONE: Uses no row-level locking, and uses a cached object if available; this is the Hibernate default.
* READ: Prevents other SELECT queries from reading data that is in the middle of a transaction (and thus possibly invalid) until it is committed.
As usual, there’s more to this than we’re discussing here. We’ll add more methods to this list as we keep going through Hibernate’s
capabilities. We’re keeping the list small for simplicity’s sake.
* UPGRADE: Uses the SELECT FOR UPDATE SQL syntax to lock the data until the transaction is finished.
* UPGRADE_NOWAIT: Uses the NOWAIT keyword (for Oracle), which returns an error immediately if there is another thread using that row; otherwise this is similar to UPGRADE.
* FORCE: Similar to UPGRADE but increments the version for objects with automatic versioning when loaded.

[source,java]
----
public Object load(Class theClass, Serializable id, LockMode lockMode) throws HibernateException 
public Object load(String entityName, Serializable id, LockMode lockMode) throws HibernateException
----
 
 
 You should not use a load() method unless you are sure that the object exists. If you are not certain, then use
one of the get() methods. The load() methods will throw an exception if the unique ID is not found in the database,
whereas the get() methods will merely return a null reference.
 

* get()   

Na podstawie danego Id metoda get() próbuje pobrać obiekt z bazy danych. Jeśli obiekt nie istnieje zwraca null.
Metoda get() w przeciwieństwie do metody load() uderza do bazy bezpośrednio.
 
[source,java]
----
public Object get(Class clazz, Serializable id) throws HibernateException
public Object get(String entityName, Serializable id) throws HibernateException
public Object get(Class clazz, Serializable id, LockMode lockMode) throws HibernateException
public Object get(String entityName, Serializable id, LockMode lockMode) throws HibernateException
----


przykład : 
[source,java]
----
Book book = (Book) session.load(Book.class, isbn);

Book book = (Book) session.get(Book.class, isbn);
----

== Zapytania
include::retrieve.adoc

== Usuwanie obiektów z bazy
DELETE FROM employee WHERE id=1;
[source,java]
----
Book book = (Book) session.get(Book.class,new Long(1));
session.delete(book);
----
Metoda ta wyrzuci wyjątek jeśli obiekt o podanym identyfikatorze nie istnieje w bazie (java.lang.IllegalArgumentException)


If the record does not exist in the database, you will face the Exception in thread
"main" java.lang.IllegalArgumentException: attempt to create delete
event with null entity exception because get() returns the null object while you try
to delete that object.
However, if you use the following code to delete the record, you will face another type of error:
Employee employee = new Employee();
employee.setId(1);
session.delete(employee);
When the preceding code is executed, you will face the Exception in thread "main"
org.hibernate.StaleStateException: Batch update returned unexpected
row count from update [0]; actual row count: 0; expected: 1 " exception.
This is because we are trying to delete Employee#1 from the database (which does not
exist), and the employee object is also not null; so, it throws an error.

== Aktualizacja 
UPDATE book SET title='jpa book' WHERE id=2;

In the preceding section, we used the update() method for updating a particular
record. Apart from this method, hibernate will provide one more useful method called
saveOrUpdate() .
This particular method is used to save or update records. Hibernate updates the records for a
given object if the identifier field is given. If an identifier is not given, then hibernate will insert
a new record.



== Merge

Merge jest odwrotną operacją do operacji refresh()
Nadpisuje encje w bazie danych wartościami encji odłączonych.

== Odświeżanie encji (Refreshing Entities)

Metoda reload odświeża wartości dla encji wartościami z bazy danych. (odwrotność do merge)

[source,java]
----
public void refresh(Object object)  throws HibernateException
 
public void refresh(Object object, LockMode lockMode)  throws HibernateException
----

* Hibernate
[source,java]
----
Object merge(Object object)
 
Object merge(String entityName, Object object)
----
[square]
* JPA
include::jpa.adoc

== Dziedziczenie
include::inheritence.adoc[]

== Trwałość przez osiągalność

Ma miejsce wtedy, gdy z obiektu trwałego jest referencja do
innego obiektu
wtedy ten inny obiekt realizuje trwałość przez osiągalność
Jest rekurencyjna
Zapewnia integralność więzów referencyjnych
graf obiektów można odtworzyć wczytując jego korzeń
Teoretycznie istnieje obiekt korzenia, z którego da przejść do
dowolnego innego obiektu trwałego
w szczególności nieosiągalne obiekty powinny być z bazy
usunięte (niewydajne)
Hibernate nie implementuje tego modelu


== Trwałość kaskadowa
Trwałość przechodnia w Hibernate
Trwałość kaskadowa
Model realizowany w Hibernate
Koncepcja podobna do trwałości przez osiągalność
Powiązania są odtwarzane na podstawie asocjacji
domyślnie, hibernate nie dokonuje analizy asocjacji
Kaskady zwykle używa się do relacji jeden-do-jednego i
jeden-do-wielu
używanie kaskady w przypadkach wiele-do-jednego i
wiele-do-wielu jest raczej bez sensu
Wartości kaskady można łączyć, np.
cascade="save-update, delete

== Criteria

== Transakcyjność
include::transactions.adoc[]

== Logowanie zdarzeń
[source,xml]
----
<property name="show_sql">true</property>
----

* Włączenie  Live Statistics
[source,xml]
----
<property name="hibernate.generate_statistics">true</property>
----

== Kaskadowość


include::cache.adoc[]

== Cache level One
Activated by default

Linked to the Hibernate session

Stores all entities that were used within a session

== Cache level two

Session independent entity store
Needs to be activated
persistence.xml or EntityManagerFactory
Transparent usage
PersistenceProvider doesn‘t need to provide it Not always portable


Cache configuration

Cache Retrieve Mode
How to read entities from the cache

Cache Store Mode
How to write entities to the cache

Concurrency Strategy
How to handle concurrent access


Stores query results for a query and its parameters

[„FROM Author WHERE id=?“, 1]     [1]

Stores only entity references or scalars

Always use together with 2nd Level Cache


Hibernate specific

Stores query result session independent

Needs to be activated
persistence.xml: hibernate.cache.use_query_cache = true

Activate caching for a specific query
org.hibernate.Query.setCacheable(true)
@NamedQuery(… hints = @QueryHint(name="org.hibernate.cacheable", value="true"))


== FetchType
* Lazy
* Eager
* Fetch all required entities with one query
 - Fetch Join
[source,java]
----
List<Author> authors = this.em.createQuery(
		"SELECT DISTINCT a FROM Author a JOIN FETCH a.books b", 
		Author.class).getResultList();
----

+ Relationships gets loaded in same query
- Requires a special query for each use case
- Creates cartesian product

		 
 - @NamedEntityGraph
 Declaratively defines a graph of entities which will be loaded
[source,java]
----
@NamedEntityGraph(
	name = "graph.AuthorBooksReviews", 

	attributeNodes = 
@NamedAttributeNode(value = "books")
)
----



Graph is query independent

 
 - EntityGraph

== Zapytania natywne  

SqlResultSetMapping

@SqlResultSetMapping(
	name		= "myResultMapping ",
	entities		= {@EntityResult(...), …},
	classes	= {@ConstructorResult (…), …},
	columns	= {@ColumnResult(…), …}
)

this.em.createNativeQuery(“Select …", "myResultMapping")


== Orphal Removal

== Walidacja

== Problemy wydajnościowe
include::performance.adoc[] 

* N+1
* Paginacja
* 

== Blokowanie

* Optymistyczne 
  OptimisticLockException
  
* Pesymistyczne  


== Rozwiązywanie problemów
A common mistake when designing entity models is to try to make all associations bidirectional

* kłopoty z pamięcią

* Problemy z wydajnością mechnika : 
 - sprawdź wygenerowane SQL
 - sprawdź execution plan 
 - sprawdź poprawność indeksów bazodanowych
 - próba optymalizacji zapytania
 - próba rozważenia zapytania natywnego
     - jpql wspiera tylko niektóre podzbiory features z bazy danych 
     - SQL dla danej bazy może być wysoce wyspecjalizowany

@Basic(lazy)      
Lazy attribute fetching: an attribute or single valued association is fetched when the instance variable is accessed.
 This approach requires buildtime bytecode instrumentation and is rarely necessary.
Emmanuel Bernard wrote  @Lob are lazy by default
@Lob
@Fetch(FetchMode.SELECT)
@Type(type="org.hibernate.type.PrimitiveByteArrayBlobType")
byte[] myBlob;


== Dobre praktyki

 - zachowanie właściwych poziomów abstrakcji podczas modelowania relacji
 - unikanie jawnych opercji save() - wzorzec 'unit of work'
 - load vs get
  Lepiej na początku jest sprawdzić czy obiekt jest null czy nie jeśli chcemy użyć metody get(). (NullPointerException problem)

 -unikaj relacji dwukierunkowych
 - tight coupling
 - cykliczność
 - utrzymanie spójności (musimy pamiętać aby obsłużyć dwie strony relacji)
 - paginacja
 - DDD agregacja
 - unikaj merge 
 - unikaj obiektów odłączonych
 - pobieranie zbyt dużych ilości danych powoduje marnowanie pamięci w warstwie aplikacji
 - 

== O mnie
* programista
* blog link:http://przewidywalna-java.blogspot.com[]
* image:{image-link} [role='img-circle']


http://undermineddeveloper.com/2013/09/11/hibernating/

