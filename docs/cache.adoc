= JPA/Hibernate camp
:docInfo1
:numbered:
:icons: font
:pagenums:
:imagesdir: img
:iconsdir: ./icons
:stylesdir: ./styles
:scriptsdir: ./js

:image-link: https://pbs.twimg.com/profile_images/425289501980639233/tUWf7KiC.jpeg
ifndef::sourcedir[:sourcedir: ./src/main/java/]
ifndef::resourcedir[:resourcedir: ./src/main/resources/]
ifndef::imgsdir[:imgsdir: ./../img]
:source-highlighter: coderay



**Cache** - zwiększenie wydajności zapytań poprzez eliminacje ponownego zapytania w bazie


image::cache1.png[]


== Architektura 

image::cache.jpg[]

- source : https://powerdream5.wordpress.com

== First level cache
   Pierwsza czynność wykonywana przez Hibernate to sprawdzenie tego obszaru pod kątem optymalizacji 

 - właczone domyślnie. Nie można go wyłączyć
 - dane są umieszczane w konteksie sesji
 - ograniczony w ramach **Session**
 - niszczony wraz z **Session**
 - jeśli hibernate szuka obiektu to najpierw w cache first level jeśli go tam nie ma uderza do bazy
 - **_Session.evict(Object object)_** -usuwa pojedyńczy obiekt z cache
 - **_Session.clear()_** - czyści wszystkie obiekty znajdujace się aktualnie w cache
 - operacja jak **Save** **Update** **Get**  **Load**  List wstawiają obiekt do first-cache
 - optymalizuje operacje **EntityManager** - w obrębie **unit of work**
 - wielokrotna operacja **find()** → jedna operacja **SELECT**
 - wielokrotne operacja **merge()** → jedna operacja  **UPDATE** 
 
 
== Second level cache
 - skojarzony z **EntityManagerFactory** lub **SessionFactory**
 - optymalizuje dostęp do encji lub kolekcji na poziomie całego kontekstu entityManagerFactory. Co sprawia, że operacja find() uderza do bazy tylko jeden raz
 
WARNING: Dla bardzo dużych woluminów danych: Wyjątkowo nieefektywne ->  **Out of memory exception** 

CAUTION: Wyjątkowo słabe skalowanie dla równoległych lub częstych uaktualnień danych
 
 

=== javax.persistence.sharedCache.mode

*    **ALL:** wszystkie encje są cachowane
    
*    **NONE:** odwrotność do **ALL**
    
*    **ENABLE_SELECTIVE:** Buforowaniem objęte są tylko encje oznaczone **@Cacheable(true)**
    
*    **DISABLE_SELECTIVE:** Buforowaniem objęte są wszystkie encje z wyjątkiem tych oznaczonych **@Cacheable(false)**
    
*    **UNSPECIFIED:** zależna od dostawcy JPA.
    


=== Retrieval Mode

This mode defines how data is read from the cache when using queries or calling the entitymanager’s find method.

We may modify the mode by setting the property javax.persistence.retrieveMode to a value of the enum javax.persistence.CacheRetrieveMode:

    BYPASS: The cache is bypassed and a call to the database is used to retrieve the data.
    USE: If the data is available in the cache, it is read from this location, else it is fetched from the database

=== Store Mode

This mode defines how data is stored in the cache.

We may modify the mode by setting the property javax.persistence.storeMode to a value of the enum javax.persistence.CacheStoreMode:

    BYPASS: Don’t put anything into the cache
    REFRESH: Data is put/updated in the cache when read and committed into the database a refresh enforced
    USE: Data is put/updated in the cache when read and committed into the database





Opcjonalny
Cache na poziomie sessionFactory

 * Dostawcy 
  Ehcache
  OSCache
  SwarmCache
  JBoss Cache
[source,xml]
----
<dependency>
  <groupId>net.sf.ehcache</groupId>
   <artifactId>ehcache-core</artifactId>
</dependency>
<dependency>
  <groupId>org.hibernate</groupId>
  <artifactId>hibernate-ehcache</artifactId>
</dependency>
----

Włączenie cache
[source,xml]
----
<property name="hibernate.cache.use_second_level_cache">true </property>
<property name="hibernate.cache.region.factory_class">net.sf.ehcache.hibernate.EhCacheRegionFactory</property>

===
<session-factory>
<property name="connection.driver_class">org.h2.Driver</property>
<property name="connection.url">jdbc:h2:file:./chapter12</property>
<property name="hibernate.dialect">org.hibernate.dialect.HSQLDialect</property>
<property name="hibernate.hbm2ddl.auto">create</property>
<property name="hibernate.show_sql">true</property>
<property name="hibernate.discriminator.ignore_explicit_for_joined">true</property>
<property name="hibernate.generate_statistics">true</property>
<property name="connection.username"></property>
<property name="connection.password"></property>
<property name="hibernate.cache.region.factory_class">
org.hibernate.cache.ehcache.EhCacheRegionFactory
</property>
<mapping class="com.apress.hibernaterecipes.chapter12.recipe2.Book2"/>
</session-factory>
</hibernate-configuration>


----


[source,java]
----
@Entity(name = "Person")
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public static class Person {
}



----

=== Strategie 

* **Read-only** - Najbardziej wydajna -  Encje są często czytane ale nigdy modyfikowane (**CacheConcurrencyStrategy.READ_ONLY**)
* **Nonstrict** read-write - Encje są rzadko modyfikowane (**CacheConcurrencyStrategy.NONSTRICT_READ_WRITE**)
* **Read-write** - Większy narzut Encje są modyfikowane (**CacheConcurrencyStrategy.READ_WRITE**)
* **Transactional**  : Dostępna jedynie w środowisku zarządzanym. Gwarantuje pełną izolację transakcyjną aż do trybu powtarzalnego odczytu. Cache wspierany przez transakcyjne cache'e jak JBOSS TreeCache (**CacheConcurrencyStrategy.TRNSACTIONAL**) 

[source,java]
----
@Entity
@Table(name="employee")
@Cache(usage=CacheConcurrencyStrategy.READ_ONLY)
public class Employee {

}
----


=== TEst

[source,java]
----
@BeforeMethod
public void clearData() {
SessionManager.deleteAll("Book2");
}
 
@Test
public void test2LCache() {
SessionFactory sessionFactory = SessionManager.getSessionFactory();
Statistics stats = sessionFactory.getStatistics();
 
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
 
Book2 book2 = new Book2();
book2.setTitle("My Title");
 
session.persist(book2);
 
203Chapter 12 ■ Caching in Hibernate
tx.commit();
session.close();
 
sessionFactory.getCache().evictAllRegions();
 
session = sessionFactory.openSession();
tx = session.beginTransaction();
 
Book2 b = (Book2) session.byId(Book2.class).load(book2.getId());
Book2 b2 = (Book2) session.byId(Book2.class).load(book2.getId());
 
assertEquals(book2, b);
assertEquals(book2, b2);
 
tx.commit();
session.close();
 
// this is the initial select
assertEquals(stats.getSecondLevelCacheMissCount(), 1);
// we put one element in the cache from the miss
assertEquals(stats.getSecondLevelCachePutCount(), 1);
// we still didn't hit the cache, because of 1L cache
assertEquals(stats.getSecondLevelCacheHitCount(), 0);
 
session = sessionFactory.openSession();
tx = session.beginTransaction();
 
b = (Book2) session.byId(Book2.class).load(book2.getId());
assertEquals(book2, b);
tx.commit();
session.close();
 
// same miss count (we should hit now)
assertEquals(stats.getSecondLevelCacheMissCount(), 1);
// same put count (we didn't put anything new)
assertEquals(stats.getSecondLevelCachePutCount(), 1);
// now we hit the 2L cache for load
assertEquals(stats.getSecondLevelCacheHitCount(), 1);
}
 
@Test(expectedExceptions = {UnsupportedOperationException.class})
public void updateReadOnly() {
Session session = SessionManager.openSession();
Transaction tx = session.beginTransaction();
Book2 book2 = new Book2();
book2.setTitle("My Title");
 
session.persist(book2);
 
tx.commit();
session.close();
 
204Chapter 12 ■ Caching in Hibernate
session = SessionManager.openSession();
try {
tx = session.beginTransaction();
 
Book2 b = (Book2) session.byId(Book2.class).load(book2.getId());
b.setTitle("The Revised Title");
session.flush();
} catch (UnsupportedOperationException e) {
tx.rollback();
session.close();
throw e;
}
tx.commit();
session.close();
fail("Should have gotten an exception");
}
----


=== Cache collection test

[source,java]
----
@Entity
@Data
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
public class Book4 {
@Id
@GeneratedValue(strategy = GenerationType.AUTO)
int id;
String title;
@OneToMany
@Cascade(CascadeType.ALL)
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
Set<Chapter4> chapters=new HashSet<>();
}
 
@Entity
@Data
@NoArgsConstructor
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
public class Chapter4 {
@Id
@GeneratedValue(strategy = GenerationType.AUTO)
int id;
String name;
public Chapter4(String name) {
setName(name);
}
}
 
 
 public class Test4 {
Book4 book4;
 
@BeforeMethod
public void clear() {
SessionManager.deleteAll("Chapter4");
SessionManager.deleteAll("Book4");
 
Session session = SessionManager.openSession();
Transaction tx = session.beginTransaction();
book4 = new Book4();
book4.setTitle("sample book");
book4.getChapters().add(new Chapter4("chapter one"));
book4.getChapters().add(new Chapter4("chapter two"));
session.persist(book4);
tx.commit();
session.close();
}
 
@Test
public void testCollectionCache() {
SessionFactory sessionFactory = SessionManager.getSessionFactory();
Statistics stats = sessionFactory.getStatistics();
 
Session session = SessionManager.openSession();
Transaction tx = session.beginTransaction();
Book4 book = (Book4) session.byId(Book4.class).load(book4.getId());
assertEquals(book.getTitle(), book4.getTitle());
assertEquals(book.getChapters().size(), 2);
tx.commit();
session.close();
assertEquals(stats.getSecondLevelCacheHitCount(), 0);
assertEquals(stats.getSecondLevelCacheMissCount(), 2);
// one book, two chapters, one collection
assertEquals(stats.getSecondLevelCachePutCount(), 4);
 
session = SessionManager.openSession();
tx = session.beginTransaction();
book = (Book4) session.byId(Book4.class).load(book4.getId());
assertEquals(book.getTitle(), book4.getTitle());
assertEquals(book.getChapters().size(), 2);
tx.commit();
session.close();
 
// should hit the book, chapters, collection now
assertEquals(stats.getSecondLevelCacheHitCount(), 4);
assertEquals(stats.getSecondLevelCacheMissCount(), 2);
// one book, two chapters, one collection
assertEquals(stats.getSecondLevelCachePutCount(), 4);
}
}
 
----

=== Cache query test


- Cache dla  kwerend

===  Konfiguracja

[source,xml]
----
<property name="hibernate.cache.use_query_cache" value="true"/>
----


NOTE:  Należy zawsze stosować z L2 cache : Query cache nie przechowuje wartości a przechowuje jedynie **id**

NOTE: Włączenie **Query cache** ma sens dla zapytań często wykonywalnych, tak samo sparametryzowanych  

[source.java]
----

Session session1 = SessionManager.openSession();
try {
Query query = session1.createQuery("from Book5 b where b.name like ?");
query.setString(0, "%Hibernate%");
List books = query.list();
} finally {
session1.close();
}
Session session2 = SessionManager.openSession();
try {
Query query = session2.createQuery("from Book5 b where b.name like ?");
query.setString(0, "%Hibernate%");
List books = query.list();
} finally {
session2.close();
}
 
 
 <hibernate-configuration>
<session-factory>
...
<property name="hibernate.cache.use_query_cache">true</property>
...
</session-factory>
</hibernate-configuration>


@Entity
@Data
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_ONLY)
public class Book5 {
@Id
@GeneratedValue(strategy = GenerationType.AUTO)
int id;
String title;
}
 
The test that shows the cache in action uses a method to execute the queries to reduce code
duplication:
 
public class Test5 {
@BeforeMethod
public void clear() {
SessionManager.deleteAll("Book5");
Session session = SessionManager.openSession();
Transaction tx = session.beginTransaction();
Book5 book5 = new Book5();
book5.setTitle("My Book");
session.persist(book5);
tx.commit();
session.close();
}
 
212Chapter 12 ■ Caching in Hibernate
public List<Book5> runQuery(boolean cacheStatus) {
Session session = SessionManager.openSession();
Transaction tx = session.beginTransaction();
Query query = session.createQuery("from Book5 b where b.title like :title");
query.setString("title", "My%");
query.setCacheable(cacheStatus);
List<Book5> books = (List<Book5>)query.list();
tx.commit();
session.close();
return books;
}
 
@Test
public void testNoQueryCache() {
SessionFactory factory=SessionManager.getSessionFactory();
Statistics stats = factory.getStatistics();
assertEquals(runQuery(false).size(), 1);
assertEquals(runQuery(false).size(), 1);
assertEquals(stats.getQueryCacheHitCount(),0);
assertEquals(stats.getSecondLevelCacheHitCount(), 0);
}
 
@Test
public void testQueryCache() {
SessionFactory factory=SessionManager.getSessionFactory();
Statistics stats = factory.getStatistics();
assertEquals(runQuery(true).size(), 1);
assertEquals(runQuery(true).size(), 1);
assertEquals(stats.getQueryCacheHitCount(),1);
assertEquals(stats.getSecondLevelCacheHitCount(), 1);
}
}
 
----


Enabling a query cache:
[source,xml]
----
<property name="hibernate.cache.use_query_cache">true</property>
----

[source,java]
----
Session session = sessionFactory.openSession();
for (int i = 0; i < 5; i++) {
/* Line 3 */ Criteria criteria = session.createCriteria(Employee.class).setCacheable(true);
List<Employee> employees = criteria.list();
System.out.println("Employees found: " + employees.size());
}
session.close();
----
[NOTE]
The query cache checks whether a particular query is cached or
not and the first-level cache checks the object in this particular cache. An invocation of the
list() method always hits the database even if the first-level cache is enabled

[WARNING]
it's clear that if we don't set setcachable to true , hibernate will not
cache our query, and the query will hit the database every time the loop iterates. This is not a
feasible option as it may downgrade the performance.

== Collection cache

[source,java]
----

@OneToMany(mappedBy = "person", cascade = CascadeType.ALL)
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
private List<Phone> phones = new ArrayList<>(  );

...
Person person = entityManager.find( Person.class, 1L );
person.getPhones().size();

----


== Query level cache
aktywowany poprzez dyrektywę : hibernate.cache.use_query_cache = true
przetrzymuje całkowite wyniki zapytania w pamieci cache.

=== aktywacja
[source,xml]
----

<property name="hibernate.cache.use_query_cache" value="true" />

----


A query’s result set can be configured to be cached. By default, caching is disabled; and every HQL, JPA QL,
and Criteria query hits the database. You enable the query cache as follows:
 
hibernate.cache.use_query_cache = true
 
In addition to setting this configuration property, you should use the org.hibernate.Query interface:
 
Query bookQuery = session.createQuery("from Book book where book.name < ?");
bookQuery.setString("name","HibernateRecipes");
bookQuery.setCacheable(true);
 
The setCacheable() method enables the result to be cached.

=== JPA
[source,java]
----


List<Person> persons = entityManager.createQuery(
    "select p " +
    "from Person p " +
    "where p.name = :name", Person.class)
.setParameter( "name", "Przodownik pracy")
.setHint( "org.hibernate.cacheable", "true")
.getResultList();


----

=== Hibernate native API

[source,java]
----

List<Person> persons = session.createQuery(
    "select p " +
    "from Person p " +
    "where p.name = :name")
.setParameter( "name", "Przodownik pracy")
.setCacheable(true)
.list();


----

==  Query cache regions

=== org.hibernate.cache.internal.StandardQueryCache  Holding the cached query results

=== org.hibernate.cache.spi.UpdateTimestampsCache Holding timestamps of the most recent updates to queryable tables. These are used to validate the results as they are served from the query cache.

=== using JPA
[source,java]
----
List<Person> persons = entityManager.createQuery(
        "select p " +
        "from Person p " +
        "where p.id > :id", Person.class)
        .setParameter( "id", 0L)
        .setHint( QueryHints.HINT_CACHEABLE, "true")
        .setHint( QueryHints.HINT_CACHE_REGION, "query.cache.person" )
        .getResultList();
----

== native Hibernate API
[source,java]
----


List<Person> persons = session.createQuery(
    "select p " +
    "from Person p " +
    "where p.id > :id")
.setParameter( "id", 0L)
.setCacheable(true)
.setCacheRegion( "query.cache.person" )
.list();


----

== Statystyki 

[source,java]
----


Statistics statistics = session.getSessionFactory().getStatistics();
SecondLevelCacheStatistics secondLevelCacheStatistics = statistics.getSecondLevelCacheStatistics( "query.cache.person" );
long hitCount = secondLevelCacheStatistics.getHitCount();
long missCount = secondLevelCacheStatistics.getMissCount();
double hitRatio = (double) hitCount / ( hitCount + missCount );


----


== Ehcache

=== RegionFactory

Regions are buckets of data of two
types: one type contains disassembled data of entity instances, and the other contains only identifiers of
entities that are linked through a collection.

==== EhCacheRegionFactory
 configures a net.sf.ehcache.CacheManager for each SessionFactory, so the CacheManager is not shared among multiple SessionFactory instances in the same JVM.


[source,xml]
----
<property name="hibernate.cache.region.factory_class" value="org.hibernate.cache.ehcache.EhCacheRegionFactory"/>
----

===== SingletonEhCacheRegionFactory 
configures a singleton net.sf.ehcache.CacheManager (see CacheManager#create()), shared among multiple SessionFactory instances in the same JVM

[source,xml]

----

<property
    name="hibernate.cache.region.factory_class"
    value="org.hibernate.cache.ehcache.SingletonEhCacheRegionFactory"/>
    
----

== TODO

uzycie cache przykłady junit
Session session = factory.openSession();
try {
Book book1 = (Book) session.get(Book.class, id);
Book book2 = (Book) session.get(Book.class, id);
} finally {
session.close();
}
 
If you inspect the SQL statements executed by Hibernate, you find that only one database query is
made. That means Hibernate is caching your objects in the same session. This kind of caching is called
first-level caching, and its caching scope is a session.
But how about getting an object with same identifier more than once in two different sessions?
 
Session session1 = factory.openSession();
try {
Book book1 = (Book) session1.get(Book.class, id);
} finally {
session1.close();
}
Session session2 = factory.openSession();
try {
Book book2 = (Book) session2.get(Book.class, id);
} finally {
session2.close();
}
 
T

== O mnie
* programista
* blog link:http://przewidywalna-java.blogspot.com[]
* image:{image-link} [role='img-circle']
