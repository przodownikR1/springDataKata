
=Lock

== Enabling Optimistic Concurrency Control

[source,java]
----

@Entity (name="bkch2")
@org.hibernate.annotations.Entity(dynamicInsert = true, dynamicUpdate = true)
@Table
(name="BOOK")
public class BookCh2 {
 
@Id
@GeneratedValue (strategy=GenerationType.TABLE)
@Column (name="ISBN")
private long isbn;
 
@Version
@Column (name="version")
private Integer version;
 
@Column (name="book_Name")
private String bookName;
 
/*@Column (name="publisher_code")
String publisherCode;*/
 
@Column (name="publish_date")
private Date publishDate;
 
@Column (name="price")
private Long price;
// getters and setters
}

----


[source,java]
----
@Entity (name="bkch2")
@org.hibernate.annotations.Entity
(dynamicInsert = true, dynamicUpdate = true,
optimisticLock=org.hibernate.annotations.OptimisticLockType.ALL)
@Table
(name="BOOK")
public class BookCh2 {
 
@Id
@GeneratedValue (strategy=GenerationType.TABLE)
@Column (name="ISBN")
private long isbn;
 
@Version
@Column (name="version")
private Integer version;
 
@Column (name="book_Name")
private String bookName;
----


== Using Pessimistic Concurrency Control

[source,java]
----

Session session = getSession();
Transaction tx = null;
tx = session.beginTransaction();
BookCh2 book = (BookCh2)session.get(BookCh2.class, new Long(32769));
String name = (String) session.createQuery("select b.name from bkch2 b where b.isbn = :isbn")
.setParameter("isbn", book.getIsbn()).uniqueResult();
System.out.println("BOOk's Name- "+name);
tx.commit();
session.close();
 
229Chapter 13 ■ Transactions and Concurrency
You can use session.lock() to upgrade the isolation level. The previous code is updated as follows:
 
Session session = getSession();
Transaction tx = null;
tx = session.beginTransaction();
BookCh2 book = (BookCh2)session.get(BookCh2.class, new Long(32769));
session.lock(book, LockMode.UPGRADE);
String name = (String) session.createQuery("select b.name from bkch2 b where b.isbn = :isbn")
.setParameter("isbn", book.getIsbn()).uniqueResult();
System.out.println("BOOk's Name- "+name);
tx.commit();
session.close();

BookCh2 book = (BookCh2)session.get(BookCh2.class, new Long(32769),LockMode.UPGRADE);
----

LockMode.NONE: This is the default lock mode. If an object is requested with this lock
mode, a READ lock is obtained if it is necessary to read the state from the database
instead of pulling it from a cache.
•	 LockMode.READ: In this lock mode, an object is read from the database. The object’s
version is checked, just as in memory.
•	 LockMode.UPGRADE: Objects loaded in this lock mode are materialized using an SQL
select ... for update. It is equivalent to LockModeType.READ in Java Persistence.
•	 LockMode.UPGRADE_NOWAIT: This lock mode attempts to obtain an upgrade lock using
an Oracle-style select for update nowait. Once obtained, the semantics of this
lock mode are the same as UPGRADE.
•	 LockMode.FORCE: This lock mode results in a forced version increment. It is
equivalent to LockModeType.Write in Java Persistence.
•	 LockMode.WRITE: A WRITE lock is obtained when an object is updated or inserted.
This lock mode is for internal use only and isn’t a valid mode for load() or lock().


NONE Reads from the database only if the object is not available from the caches.
READ Reads from the database regardless of the contents of the caches.
UPGRADE Obtains a dialect-specific upgrade lock for the data to be accessed (if this is available from
your database).
UPGRADE_NOWAIT Behaves like UPGRADE, but when support is available from the database and dialect, the method
will fail with a locking exception immediately. Without this option, or on databases for which it
is not supported, the query must wait for a lock to be granted (or for a timeout to occur).

